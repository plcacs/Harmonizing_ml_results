import io
import pathlib
from collections import defaultdict
from typing import Any, DefaultDict, IO, Set, List
import multidict

ROOT: pathlib.Path = pathlib.Path.cwd()
while ROOT.parent != ROOT and (not (ROOT / 'pyproject.toml').exists()):
    ROOT = ROOT.parent

def calc_headers(root: pathlib.Path) -> List[multidict.istr]:
    hdrs_file: pathlib.Path = root / 'aiohttp/hdrs.py'
    code = compile(hdrs_file.read_text(), str(hdrs_file), 'exec')
    globs: dict[str, Any] = {}
    exec(code, globs)
    headers: List[multidict.istr] = [val for val in globs.values() if isinstance(val, multidict.istr)]
    return sorted(headers)

headers: List[multidict.istr] = calc_headers(ROOT)

def factory() -> DefaultDict[Any, Any]:
    return defaultdict(factory)

TERMINAL: object = object()

def build(headers: List[multidict.istr]) -> DefaultDict[Any, Any]:
    dct: DefaultDict[Any, Any] = defaultdict(factory)
    for hdr in headers:
        d: Any = dct
        for ch in hdr:
            d = d[ch]
        d[TERMINAL] = hdr
    return dct

dct: DefaultDict[Any, Any] = build(headers)

HEADER: str = ('/*  The file is autogenerated from aiohttp/hdrs.py\n'
               'Run ./tools/gen.py to update it after the origin changing. */\n\n'
               '#include "_find_header.h"\n\n'
               '#define NEXT_CHAR() \\\n'
               '{ \\\n'
               '    count++; \\\n'
               '    if (count == size) { \\\n'
               '        /* end of search */ \\\n'
               '        return -1; \\\n'
               '    } \\\n'
               '    pchar++; \\\n'
               '    ch = *pchar; \\\n'
               '    last = (count == size -1); \\\n'
               '} while(0);\n\n'
               'int\n'
               'find_header(const char *str, int size)\n'
               '{\n'
               '    char *pchar = str;\n'
               '    int last;\n'
               '    char ch;\n'
               '    int count = -1;\n'
               '    pchar--;\n')

BLOCK: str = ('\n{label}\n'
              '    NEXT_CHAR();\n'
              '    switch (ch) {{\n'
              '{cases}\n'
              '        default:\n'
              '            return -1;\n'
              '    }}\n')

CASE: str = ("        case '{char}':\n"
             "            if (last) {{\n"
             "                return {index};\n"
             "            }}\n"
             "            goto {next};")

FOOTER: str = ('\n{missing}\n'
                'missing:\n'
                '    /* nothing found */\n'
                '    return -1;\n'
                '}\n')

def gen_prefix(prefix: str, k: str) -> str:
    if k == '-':
        return prefix + '_'
    else:
        return prefix + k.upper()

def gen_block(
    dct: DefaultDict[Any, Any],
    prefix: str,
    used_blocks: Set[str],
    missing: Set[str],
    out: IO[str]
) -> None:
    cases: dict[str, str] = {}
    for k, v in dct.items():
        if k is TERMINAL:
            continue
        next_prefix: str = gen_prefix(prefix, k)  # type: ignore
        term: Any = v.get(TERMINAL)
        if term is not None:
            index: int = headers.index(term)
        else:
            index = -1
        hi: str = k.upper()  # type: ignore
        lo: str = k.lower()  # type: ignore
        case_hi: str = CASE.format(char=hi, index=index, next=next_prefix)
        cases[hi] = case_hi
        if lo != hi:
            case_lo: str = CASE.format(char=lo, index=index, next=next_prefix)
            cases[lo] = case_lo
    label: str = prefix + ':' if prefix else ''
    if cases:
        block: str = BLOCK.format(label=label, cases='\n'.join(cases.values()))
        out.write(block)
    else:
        missing.add(label)
    for k, v in dct.items():
        if not isinstance(v, defaultdict):
            continue
        block_name: str = gen_prefix(prefix, k)  # type: ignore
        if block_name in used_blocks:
            continue
        used_blocks.add(block_name)
        gen_block(v, block_name, used_blocks, missing, out)

def gen(dct: DefaultDict[Any, Any]) -> io.StringIO:
    out: io.StringIO = io.StringIO()
    out.write(HEADER)
    missing: Set[str] = set()
    gen_block(dct, '', set(), missing, out)
    missing_labels: str = '\n'.join(sorted(missing))
    out.write(FOOTER.format(missing=missing_labels))
    return out

def gen_headers(headers: List[multidict.istr]) -> io.StringIO:
    out: io.StringIO = io.StringIO()
    out.write('# The file is autogenerated from aiohttp/hdrs.py\n')
    out.write('# Run ./tools/gen.py to update it after the origin changing.')
    out.write('\n\n')
    out.write('from . import hdrs\n')
    out.write('cdef tuple headers = (\n')
    for hdr in headers:
        out.write('    hdrs.{},\n'.format(hdr.upper().replace('-', '_')))
    out.write(')\n')
    return out

folder: pathlib.Path = ROOT / 'aiohttp'
with (folder / '_find_header.c').open('w') as f:
    f.write(gen(dct).getvalue())
with (folder / '_headers.pxi').open('w') as f:
    f.write(gen_headers(headers).getvalue())