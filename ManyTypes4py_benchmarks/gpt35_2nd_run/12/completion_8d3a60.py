from typing import List, Iterator, Union

class ParamNameWithEquals(ParamNameWrapper):
    def get_public_name(self) -> str:
        return self.string_name + '='

def _get_signature_param_names(signatures: List, positional_count: int, used_kwargs: List[str]) -> Iterator[ParamNameWithEquals]:
    ...

def _must_be_kwarg(signatures: List, positional_count: int, used_kwargs: List[str]) -> bool:
    ...

def filter_names(inference_state, completion_names, stack, like_name, fuzzy, cached_name) -> Iterator[classes.Completion]:
    ...

def _remove_duplicates(completions: List[classes.Completion], other_completions: List[classes.Completion]) -> List[classes.Completion]:
    ...

def get_user_context(module_context, position) -> ModuleContext:
    ...

def get_flow_scope_node(module_node, position) -> Union[tree.Scope, tree.Flow]:
    ...

def complete_param_names(context, function_name, decorator_nodes) -> List:
    ...

class Completion:
    def __init__(self, inference_state, module_context, code_lines, position, signatures_callback, fuzzy=False):
        ...

    def complete(self) -> List[classes.Completion]:
        ...

    def _complete_python(self, leaf) -> Tuple[Optional[str], List[classes.Completion]]:
        ...

    def _is_parameter_completion(self) -> bool:
        ...

    def _complete_params(self, leaf) -> List:
        ...

    def _complete_keywords(self, allowed_transitions, only_values) -> Iterator[keywords.KeywordName]:
        ...

    def _complete_global_scope(self) -> List:
        ...

    def _complete_trailer(self, previous_leaf) -> Tuple[Optional[str], List[classes.Completion]]:
        ...

    def _complete_trailer_for_values(self, values) -> List[classes.Completion]:
        ...

    def _get_importer_names(self, names, level=0, only_modules=True) -> List:
        ...

    def _complete_inherited(self, is_function=True) -> Iterator:
        ...

    def _complete_in_string(self, start_leaf, string) -> List:
        ...

    def _complete_code_lines(self, code_lines) -> List:
        ...

def _gather_nodes(stack) -> List:
    ...

def _extract_string_while_in_string(leaf, position) -> Tuple[Optional[str], Optional[Leaf], Optional[str]]:
    ...

def complete_trailer(user_context, values) -> List:
    ...

def _complete_getattr(user_context, instance) -> List:
    ...

def search_in_module(inference_state, module_context, names, wanted_names, wanted_type, complete=False, fuzzy=False, ignore_imports=False, convert=False) -> Iterator[Union[classes.Completion, classes.Name]]:
    ...
