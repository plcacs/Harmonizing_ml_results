from typing import List, Tuple, Iterable, Union, Optional, Any, Dict, Callable, Awaitable

def _headers_to_native_string(headers: List[Tuple[bytes, bytes]]) -> Iterable[Tuple[str, str]]:
    ...

def _stringify_headers(headers: List[Tuple[str, str]]) -> Iterable[Tuple[bytes, bytes]]:
    ...

def _read_readable(readable: Any) -> Iterable[bytes]:
    ...

def _make_body_iterable(body: Optional[Union[bytes, Iterable[bytes], Any]]) -> Iterable[bytes]:
    ...

def _request_bytes_iterable(request: Request, state_machine: h11.Connection) -> Iterable[Awaitable]:
    ...

def _response_from_h11(h11_response: h11.Response, body_object: Any) -> Response:
    ...

def _build_tunnel_request(host: str, port: int, headers: List[Tuple[bytes, bytes]]) -> Request:
    ...

async def _start_http_request(request: Request, state_machine: h11.Connection, conn: Any) -> h11.Response:
    ...

async def _read_until_event(state_machine: h11.Connection, conn: Any) -> Any:
    ...

class HTTP1Connection:
    default_socket_options: List[Tuple[int, int, int]] = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]

    def __init__(self, host: str, port: int, backend: Any = None, socket_options: Union[List[Tuple[int, int, int]], object] = _DEFAULT_SOCKET_OPTIONS, source_address: Optional[str] = None, tunnel_host: Optional[str] = None, tunnel_port: Optional[int] = None, tunnel_headers: Optional[List[Tuple[bytes, bytes]]] = None):
        ...

    async def _wrap_socket(self, conn: Any, ssl_context: Any, fingerprint: Optional[bytes], assert_hostname: Optional[bool]) -> Any:
        ...

    async def send_request(self, request: Request, read_timeout: int) -> Response:
        ...

    async def _tunnel(self, conn: Any) -> None:
        ...

    async def connect(self, ssl_context: Optional[Any] = None, fingerprint: Optional[bytes] = None, assert_hostname: Optional[bool] = None, connect_timeout: Optional[int] = None) -> None:
        ...

    def close(self) -> None:
        ...

    def is_dropped(self) -> bool:
        ...

    def _reset(self) -> None:
        ...

    @property
    def complete(self) -> bool:
        ...

    def __aiter__(self) -> 'HTTP1Connection':
        ...

    def next(self) -> Any:
        ...

    async def __anext__(self) -> bytes:
        ...
