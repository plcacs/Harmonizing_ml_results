from raiden.transfer.state import BalanceProofSignedState, BalanceProofUnsignedState, ChannelState, HashTimeLockState, PendingLocksState, RouteState
from raiden.utils.typing import Address, Any, Balance, BlockNumber, BlockOffset, Callable, ChainID, FeeAmount, List, LockedAmount, MYPY_ANNOTATION, Nonce, Optional, PaymentAmount, PaymentID, PaymentWithFeeAmount, SecretHash, TargetAddress, TokenAddress, TokenAmount, TokenNetworkAddress

def sign_and_inject(message: SignedMessage, signer: Signer, app: RaidenService) -> None:
    ...

def get_channelstate(app0: RaidenService, app1: RaidenService, token_network_address: TokenNetworkAddress) -> ChannelState:
    ...

def create_route_state_for_route(apps: List[RaidenService], token_address: TokenAddress, fee_estimate: Optional[FeeAmount] = None) -> RouteState:
    ...

def patch_transfer_routes(routes: List[List[RaidenService]], token_address: TokenAddress) -> None:
    ...

def watch_for_unlock_failures(*apps: RaidenService) -> None:
    ...

def transfer(initiator_app: RaidenService, target_app: RaidenService, token_address: TokenAddress, amount: PaymentAmount, identifier: PaymentID, timeout: Optional[int] = None, transfer_state: TransferState = TransferState.UNLOCKED, expect_unlock_failures: bool = False, routes: Optional[List[List[RaidenService]]] = None) -> SecretHash:
    ...

def transfer_and_assert_path(path: List[RaidenService], token_address: TokenAddress, amount: PaymentAmount, identifier: PaymentID, timeout: int = 10, fee_estimate: FeeAmount = FeeAmount(0)) -> SecretHash:
    ...

def assert_deposit(token_network_address: TokenNetworkAddress, app0: RaidenService, app1: RaidenService, saved_state0: SavedState, saved_state1: SavedState) -> None:
    ...

def assert_balance_proof(token_network_address: TokenNetworkAddress, app0: RaidenService, app1: RaidenService, saved_state0: SavedState, saved_state1: SavedState) -> None:
    ...

def assert_channel_values(channel0: ChannelState, balance0: Balance, pending_locks0: PendingLocksState, channel1: ChannelState, balance1: Balance, pending_locks1: PendingLocksState) -> None:
    ...

def assert_synced_channel_state(token_network_address: TokenNetworkAddress, app0: RaidenService, balance0: Balance, pending_locks0: PendingLocksState, app1: RaidenService, balance1: Balance, pending_locks1: PendingLocksState) -> None:
    ...

def assert_succeeding_transfer_invariants(token_network_address: TokenNetworkAddress, app0: RaidenService, balance0: Balance, pending_locks0: PendingLocksState, app1: RaidenService, balance1: Balance, pending_locks1: PendingLocksState) -> None:
    ...

def wait_assert(func: Callable, *args: Any, **kwargs: Any) -> None:
    ...

def assert_mirror(original: ChannelState, mirror: ChannelState) -> None:
    ...

def assert_locked(from_channel: ChannelState, pending_locks: PendingLocksState) -> None:
    ...

def assert_balance(from_channel: ChannelState, balance: Balance, locked: LockedAmount) -> None:
    ...

def assert_dropped(iteration: TransitionResult, old_state: Any, reason: Optional[str] = None) -> None:
    ...

def make_receive_transfer_mediated(channel_state: ChannelState, privkey: bytes, nonce: Nonce, transferred_amount: TokenAmount, lock: HashTimeLockState, pending_locks: Optional[PendingLocksState] = None, locked_amount: Optional[LockedAmount] = None, chain_id: Optional[ChainID] = None) -> BalanceProofSignedState:
    ...

def make_receive_expired_lock(channel_state: ChannelState, privkey: bytes, nonce: Nonce, transferred_amount: TokenAmount, lock: HashTimeLockState, locked_amount: LockedAmount, pending_locks: Optional[PendingLocksState] = None, chain_id: Optional[ChainID] = None) -> ReceiveLockExpired:
    ...

def block_offset_timeout(raiden: RaidenService, error_message: Optional[str] = None, offset: Optional[BlockOffset] = None, safety_margin: int = 5) -> BlockTimeout:
    ...

def block_timeout_for_transfer_by_secrethash(raiden: RaidenService, secrethash: SecretHash, error_message: Optional[str] = None) -> BlockTimeout:
    ...

def calculate_fee_for_amount(amount: PaymentAmount) -> FeeAmount:
    ...
