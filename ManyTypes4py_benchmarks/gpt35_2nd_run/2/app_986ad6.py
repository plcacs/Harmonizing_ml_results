from typing import Any, Callable, ClassVar, Dict, Iterable, List, Optional, Tuple, Type
from mode.signals import BaseSignalT
from mode.utils.times import Seconds
import faust
from faust.app.base import SCAN_CATEGORIES
from faust.sensors.base import Sensor
from faust.types import AgentT, AppT, EventT, StreamT, TP, TopicT
from .case import Case
from .exceptions import LiveCheckError
from .models import SignalEvent, TestExecution, TestReport
from .signals import BaseSignal, Signal

class LiveCheckSensor(Sensor):
    def on_stream_event_in(self, tp: TP, offset: int, stream: StreamT, event: EventT) -> None: ...

    def on_stream_event_out(self, tp: TP, offset: int, stream: StreamT, event: EventT, state: Optional[Any] = None) -> None: ...

class LiveCheck(faust.App):
    SCAN_CATEGORIES: ClassVar[List[str]] = list(SCAN_CATEGORIES)
    Signal: Type[BaseSignal] = Signal
    Case: Type[Case] = Case
    bus_concurrency: int = 30
    test_concurrency: int = 100
    send_reports: bool = True
    test_topic_name: str = 'livecheck'
    bus_topic_name: str = 'livecheck-bus'
    report_topic_name: str = 'livecheck-report'

    @classmethod
    def for_app(cls, app: AppT, *, prefix: str = 'livecheck-', web_port: int = 9999, test_topic_name: Optional[str] = None, bus_topic_name: Optional[str] = None, report_topic_name: Optional[str] = None, bus_concurrency: Optional[int] = None, test_concurrency: Optional[int] = None, send_reports: Optional[bool] = None, **kwargs: Any) -> 'LiveCheck': ...

    def _contribute_to_app(self, app: AppT) -> None: ...

    def __init__(self, id: str, *, test_topic_name: Optional[str] = None, bus_topic_name: Optional[str] = None, report_topic_name: Optional[str] = None, bus_concurrency: Optional[int] = None, test_concurrency: Optional[int] = None, send_reports: Optional[bool] = None, **kwargs: Any) -> None: ...

    @property
    def current_test(self) -> Optional[TestExecution]: ...

    @cached_property
    def _can_resolve(self) -> asyncio.Event: ...

    def _apply_monkeypatches(self) -> None: ...

    def _connect_signals(self) -> None: ...

    def on_produce_attach_test_headers(self, sender: Any, key: Any = None, value: Any = None, partition: Any = None, timestamp: Any = None, headers: List[Tuple[str, bytes]] = None, signal: Optional[BaseSignalT] = None, **kwargs: Any) -> None: ...

    def case(self, *, name: Optional[str] = None, probability: Optional[float] = None, warn_stalled_after: timedelta = timedelta(minutes=30), active: Optional[bool] = None, test_expires: Optional[Seconds] = None, frequency: Optional[Seconds] = None, max_history: Optional[int] = None, max_consecutive_failures: Optional[int] = None, url_timeout_total: Optional[float] = None, url_timeout_connect: Optional[float] = None, url_error_retries: Optional[int] = None, url_error_delay_min: Optional[float] = None, url_error_delay_backoff: Optional[float] = None, url_error_delay_max: Optional[float] = None, base: Type[Case] = Case) -> Callable[[Type], Type]: ...

    def _extract_signals(self, case_cls: Type, base_case: Type) -> Iterable[Tuple[str, Type[BaseSignal]]]: ...

    def add_case(self, case: Case) -> Case: ...

    async def post_report(self, report: TestReport) -> None: ...

    async def on_start(self) -> None: ...

    async def on_started(self) -> None: ...

    def _install_bus_agent(self) -> AgentT: ...

    def _install_test_execution_agent(self) -> AgentT: ...

    async def _populate_signals(self, events: Dict[str, SignalEvent]) -> None: ...

    async def _execute_tests(self, tests: Dict[str, TestExecution]) -> None: ...

    def _prepare_case_name(self, name: str) -> str: ...
