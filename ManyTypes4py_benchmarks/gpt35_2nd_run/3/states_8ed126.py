def to_state_create(state: State) -> StateCreate:
    ...

def get_state_result(state: State, raise_on_failure: bool = True, fetch: bool = True, retry_result_failure: bool = True) -> Any:
    ...

async def _get_state_result_data_with_retries(state: State, retry_result_failure: bool = True) -> Any:
    ...

async def _get_state_result(state: State, raise_on_failure: bool, retry_result_failure: bool = True) -> Any:
    ...

def format_exception(exc: Exception, tb: Optional[TracebackType] = None) -> str:
    ...

async def exception_to_crashed_state(exc: Exception, result_store: Optional[ResultStore] = None) -> Crashed:
    ...

async def exception_to_failed_state(exc: Optional[Exception] = None, result_store: Optional[ResultStore] = None, write_result: bool = False, **kwargs) -> Failed:
    ...

async def return_value_to_state(retval: Any, result_store: ResultStore, key: Optional[str] = None, expiration: Optional[datetime] = None, write_result: bool = False) -> State:
    ...

async def get_state_exception(state: State) -> Exception:
    ...

async def raise_state_exception(state: State) -> None:
    ...

def is_state_iterable(obj: Any) -> bool:
    ...

class StateGroup:
    ...

def _traced(cls: Type[State], **kwargs) -> State:
    ...

def Scheduled(cls: Type[State] = State, scheduled_time: Optional[datetime] = None, **kwargs) -> State:
    ...

def Completed(cls: Type[State] = State, **kwargs) -> State:
    ...

def Running(cls: Type[State] = State, **kwargs) -> State:
    ...

def Failed(cls: Type[State] = State, **kwargs) -> State:
    ...

def Crashed(cls: Type[State] = State, **kwargs) -> State:
    ...

def Cancelling(cls: Type[State] = State, **kwargs) -> State:
    ...

def Cancelled(cls: Type[State] = State, **kwargs) -> State:
    ...

def Pending(cls: Type[State] = State, **kwargs) -> State:
    ...

def Paused(cls: Type[State] = State, timeout_seconds: Optional[int] = None, pause_expiration_time: Optional[datetime] = None, reschedule: bool = False, pause_key: Optional[str] = None, **kwargs) -> State:
    ...

def Suspended(cls: Type[State] = State, timeout_seconds: Optional[int] = None, pause_expiration_time: Optional[datetime] = None, pause_key: Optional[str] = None, **kwargs) -> State:
    ...

def AwaitingRetry(cls: Type[State] = State, scheduled_time: Optional[datetime] = None, **kwargs) -> State:
    ...

def AwaitingConcurrencySlot(cls: Type[State] = State, scheduled_time: Optional[datetime] = None, **kwargs) -> State:
    ...

def Retrying(cls: Type[State] = State, **kwargs) -> State:
    ...

def Late(cls: Type[State] = State, scheduled_time: Optional[datetime] = None, **kwargs) -> State:
    ...
