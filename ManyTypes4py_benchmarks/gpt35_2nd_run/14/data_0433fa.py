from typing import Any, Union, TypeVar, Tuple, Dict, List, Set, FrozenSet

T = TypeVar('T')
TargetObservations = Dict[str, Union[int, float]]
MisalignedAt = Tuple[int, Any, Any, Union[Any, None]]
Status = Union[0, 1, 2, 3]
StructuralCoverageTag = Tuple[str]
TypeAlias = Any
SearchStrategy = Any
Ex = Any

def __getattr__(name: str) -> Any:
    ...

def structural_coverage(label: str) -> StructuralCoverageTag:
    ...

class ExtraInformation:
    def __repr__(self) -> str:
        ...
    def has_information(self) -> bool:
        ...

class Status(IntEnum):
    ...

@attr.s(slots=True, frozen=True)
class StructuralCoverageTag:
    label: str

def structural_coverage(label: str) -> StructuralCoverageTag:
    ...

class Example:
    def __init__(self, owner: Any, index: int) -> None:
        ...
    def __eq__(self, other: Any) -> bool:
        ...
    def __ne__(self, other: Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def label(self) -> Any:
        ...
    @property
    def parent(self) -> Union[int, None]:
        ...
    @property
    def start(self) -> Any:
        ...
    @property
    def end(self) -> Any:
        ...
    @property
    def depth(self) -> int:
        ...
    @property
    def discarded(self) -> bool:
        ...
    @property
    def choice_count(self) -> int:
        ...
    @property
    def children(self) -> List[Any]:

class ExampleProperty:
    def __init__(self, examples: Any) -> None:
        ...
    def run(self) -> Any:
        ...
    def __push(self, label_index: int) -> None:
        ...
    def __pop(self, discarded: bool) -> None:
        ...
    def start_example(self, i: int, label_index: int) -> None:
        ...
    def stop_example(self, i: int, discarded: bool) -> None:
        ...
    def finish(self) -> Any:

class ExampleRecord:
    def __init__(self) -> None:
        ...
    def freeze(self) -> None:
        ...
    def record_choice(self) -> None:
        ...
    def start_example(self, label: Any) -> None:
        ...
    def stop_example(self, discard: bool) -> None:
        ...

class Examples:
    def __init__(self, record: Any) -> None:
        ...
    @property
    def starts_and_ends(self) -> Tuple[List[int], List[int]]:
        ...
    @property
    def starts(self) -> List[int]:
        ...
    @property
    def ends(self) -> List[int]:
        ...
    @property
    def discarded(self) -> FrozenSet[int]:
        ...
    @property
    def parentage(self) -> List[int]:
        ...
    @property
    def depths(self) -> List[int]:
        ...
    @property
    def label_indices(self) -> List[int]:
        ...
    @property
    def mutator_groups(self) -> List[Set[Tuple[int, int]]]:
        ...
    @property
    def children(self) -> List[List[Any]]:
    def __len__(self) -> int:
        ...
    def __getitem__(self, i: int) -> Any:
        ...
    def __iter__(self) -> Iterator:

class _Overrun:
    status: Status

class DataObserver:
    def conclude_test(self, status: Status, interesting_origin: Any) -> None:
        ...
    def kill_branch(self) -> None:
        ...
    def draw_integer(self, value: int, kwargs: Dict[str, Any], was_forced: bool) -> None:
        ...
    def draw_float(self, value: float, kwargs: Dict[str, Any], was_forced: bool) -> None:
        ...
    def draw_string(self, value: str, kwargs: Dict[str, Any], was_forced: bool) -> None:
        ...
    def draw_bytes(self, value: bytes, kwargs: Dict[str, Any], was_forced: bool) -> None:
        ...
    def draw_boolean(self, value: bool, kwargs: Dict[str, Any], was_forced: bool) -> None:
        ...

@attr.s(slots=True)
class ConjectureResult:
    status: Status
    interesting_origin: Any
    nodes: Tuple[Any]
    length: int
    output: str
    extra_information: ExtraInformation
    expected_exception: Any
    expected_traceback: Any
    has_discards: bool
    target_observations: TargetObservations
    tags: FrozenSet[StructuralCoverageTag]
    examples: Examples
    arg_slices: Set[Any]
    slice_comments: Dict[Any, Any]
    misaligned_at: MisalignedAt

    def as_result(self) -> 'ConjectureResult':
        ...
    @property
    def choices(self) -> Tuple[Any]:

class ConjectureData:
    @classmethod
    def for_choices(cls, choices: Any, observer: DataObserver, provider: Type[TypeAlias], random: Any) -> 'ConjectureData':
        ...
    def __init__(self, random: Any, observer: DataObserver, provider: Type[TypeAlias], prefix: Any, max_choices: int, provider_kw: Dict[str, Any]) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def choices(self) -> Tuple[Any]:
        ...
    def _draw(self, choice_type: str, kwargs: Dict[str, Any], observe: bool, forced: Any) -> Any:
        ...
    def draw_integer(self, min_value: int, max_value: int, weights: Dict[int, float], shrink_towards: int, forced: int, observe: bool) -> int:
        ...
    def draw_float(self, min_value: float, max_value: float, allow_nan: bool, smallest_nonzero_magnitude: float, forced: float, observe: bool) -> float:
        ...
    def draw_string(self, intervals: Any, min_size: int, max_size: int, forced: str, observe: bool) -> str:
        ...
    def draw_bytes(self, min_size: int, max_size: int, forced: bytes, observe: bool) -> bytes:
        ...
    def draw_boolean(self, p: float, forced: bool, observe: bool) -> bool:
        ...
    def _pooled_kwargs(self, choice_type: str, kwargs: Dict[str, Any]) -> Dict[str, Any]:
        ...
    def _pop_choice(self, choice_type: str, kwargs: Dict[str, Any], forced: Any) -> Any:
        ...
    def note(self, value: Any) -> None:
        ...
    def draw(self, strategy: Any, label: Any, observe_as: Any) -> Any:
        ...
    def start_example(self, label: Any) -> None:
        ...
    def stop_example(self, discard: bool) -> None:
        ...
    @property
    def examples(self) -> Examples:
        ...
    def freeze(self) -> None:
        ...
    def choice(self, values: List[Any], forced: Any, observe: bool) -> Any:
        ...
    def conclude_test(self, status: Status, interesting_origin: Any) -> None:
        ...
    def mark_interesting(self, interesting_origin: Any) -> None:
        ...
    def mark_invalid(self, why: str) -> None:
        ...
    def mark_overrun(self) -> None:
        ...
    def as_result(self) -> Union[_Overrun, ConjectureResult]:
        ...
    def __assert_not_frozen(self, name: str) -> None:
        ...
