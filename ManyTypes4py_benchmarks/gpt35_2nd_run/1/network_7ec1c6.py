from typing import List, Tuple, Iterable, Optional, Union

def check_channel(app1: RaidenService, app2: RaidenService, token_network_address: TokenNetworkAddress, settle_timeout: BlockTimeout, deposit_amount: TokenAmount) -> None:
    ...

def payment_channel_open_and_deposit(app0: RaidenService, app1: RaidenService, token_address: TokenAddress, deposit: TokenAmount, settle_timeout: BlockTimeout) -> None:
    ...

def create_all_channels_for_network(app_channels: List[Tuple[RaidenService, RaidenService]], token_addresses: List[TokenAddress], channel_individual_deposit: TokenAmount, channel_settle_timeout: BlockTimeout) -> None:
    ...

def network_with_minimum_channels(apps: List[RaidenService], channels_per_node: Union[int, object]) -> Iterable[Tuple[RaidenService, RaidenService]]:
    ...

def create_network_channels(raiden_apps: List[RaidenService], channels_per_node: Union[int, object]) -> List[Tuple[RaidenService, RaidenService]]:
    ...

def create_sequential_channels(raiden_apps: List[RaidenService], channels_per_node: Union[int, object]) -> List[Tuple[RaidenService, RaidenService]]:
    ...

def create_apps(chain_id: ChainID, contracts_path: Path, blockchain_services: List[BlockchainServices], token_network_registry_address: TokenNetworkRegistryAddress, one_to_n_address: Optional[OneToNAddress], secret_registry_address: SecretRegistryAddress, service_registry_address: ServiceRegistryAddress, user_deposit_address: UserDepositAddress, monitoring_service_contract_address: MonitoringServiceAddress, reveal_timeout: BlockTimeout, settle_timeout: BlockTimeout, database_basedir: Path, retry_interval_initial: float, retry_interval_max: float, retries_before_backoff: int, environment_type: Environment, unrecoverable_error_should_crash: bool, local_matrix_url: Optional[str], routing_mode: RoutingMode, blockchain_query_interval: float, resolver_ports: List[Port], enable_rest_api: bool, port_generator: Iterator[Port], capabilities_config: CapabilitiesConfig) -> List[RaidenService]:
    ...

def jsonrpc_services(proxy_manager: ProxyManager, private_keys: List[PrivateKey], secret_registry_address: SecretRegistryAddress, service_registry_address: ServiceRegistryAddress, token_network_registry_address: TokenNetworkRegistryAddress, web3: Web3, contract_manager: ContractManager) -> BlockchainServices:
    ...

def wait_for_alarm_start(raiden_apps: List[RaidenService], retry_timeout: float = DEFAULT_RETRY_TIMEOUT) -> None:
    ...

def wait_for_usable_channel(raiden: RaidenService, partner_address: Address, token_network_registry_address: TokenNetworkRegistryAddress, token_address: TokenAddress, our_deposit: TokenAmount, partner_deposit: TokenAmount, retry_timeout: float = DEFAULT_RETRY_TIMEOUT) -> None:
    ...

def wait_for_token_networks(raiden_apps: List[RaidenService], token_network_registry_address: TokenNetworkRegistryAddress, token_addresses: List[TokenAddress], retry_timeout: float = DEFAULT_RETRY_TIMEOUT) -> None:
    ...

def wait_for_channels(app_channels: List[Tuple[RaidenService, RaidenService]], token_network_registry_address: TokenNetworkRegistryAddress, token_addresses: List[TokenAddress], deposit: TokenAmount, retry_timeout: float = DEFAULT_RETRY_TIMEOUT) -> None:
    ...
