import copy
import re
import warnings
from functools import lru_cache, partial
from typing import Any, Callable, Iterable, Optional, Tuple, Union, Pattern
from hypothesis.errors import HypothesisWarning, InvalidArgument
from hypothesis.internal import charmap
from hypothesis.internal.conjecture.providers import COLLECTION_DEFAULT_MAX_SIZE
from hypothesis.internal.filtering import max_len, min_len
from hypothesis.internal.intervalsets import IntervalSet
from hypothesis.internal.reflection import get_pretty_function_description
from hypothesis.strategies._internal.collections import ListStrategy
from hypothesis.strategies._internal.lazy import unwrap_strategies
from hypothesis.strategies._internal.strategies import OneOfStrategy, SampledFromStrategy, SearchStrategy
from hypothesis.vendor.pretty import pretty

@lru_cache(maxsize=None)
def _check_is_single_character(c: Any) -> str:
    if not isinstance(c, str):
        type_ = get_pretty_function_description(type(c))
        raise InvalidArgument(f'Got non-string {c!r} (type {type_})')
    if len(c) != 1:
        raise InvalidArgument(f'Got {c!r} (length {len(c)} != 1)')
    return c

class OneCharStringStrategy(SearchStrategy):
    """A strategy which generates single character strings of text type."""

    def __init__(self, intervals: IntervalSet, force_repr: Optional[str] = None) -> None:
        assert isinstance(intervals, IntervalSet)
        self.intervals: IntervalSet = intervals
        self._force_repr: Optional[str] = force_repr

    @classmethod
    def from_characters_args(
        cls,
        *,
        codec: Optional[str] = None,
        min_codepoint: Optional[int] = None,
        max_codepoint: Optional[int] = None,
        categories: Optional[Iterable[str]] = None,
        exclude_characters: Optional[str] = None,
        include_characters: Optional[str] = None,
    ) -> "OneCharStringStrategy":
        assert set(categories or ()) <= set(charmap.categories())
        intervals: IntervalSet = charmap.query(
            min_codepoint=min_codepoint,
            max_codepoint=max_codepoint,
            categories=categories,
            exclude_characters=exclude_characters,
            include_characters=include_characters,
        )
        if codec is not None:
            intervals &= charmap.intervals_from_codec(codec)
        _arg_repr = ', '.join(
            (
                f'{k}={v!r}'
                for k, v in [
                    ('codec', codec),
                    ('min_codepoint', min_codepoint),
                    ('max_codepoint', max_codepoint),
                    ('categories', categories),
                    ('exclude_characters', exclude_characters),
                    ('include_characters', include_characters),
                ]
                if v not in (None, '', set(charmap.categories()) - {'Cs'})
            )
        )
        if not intervals:
            raise InvalidArgument(
                f'No characters are allowed to be generated by this combination of arguments: {_arg_repr}'
            )
        return cls(intervals, force_repr=f'characters({_arg_repr})')

    @classmethod
    def from_alphabet(cls, alphabet: Union[str, SearchStrategy]) -> "OneCharStringStrategy":
        if isinstance(alphabet, str):
            return cls.from_characters_args(categories=(), include_characters=alphabet)
        assert isinstance(alphabet, SearchStrategy)
        char_strategy: Any = unwrap_strategies(alphabet)
        if isinstance(char_strategy, cls):
            return char_strategy
        elif isinstance(char_strategy, SampledFromStrategy):
            for c in char_strategy.elements:
                _check_is_single_character(c)
            return cls.from_characters_args(categories=(), include_characters=char_strategy.elements)
        elif isinstance(char_strategy, OneOfStrategy):
            intervals: IntervalSet = IntervalSet()
            for s in char_strategy.element_strategies:
                intervals = intervals.union(cls.from_alphabet(s).intervals)
            return cls(intervals, force_repr=repr(alphabet))
        raise InvalidArgument(f'alphabet={alphabet!r} must be a sampled_from() or characters() strategy')

    def __repr__(self) -> str:
        return self._force_repr or f'OneCharStringStrategy({self.intervals!r})'

    def do_draw(self, data: Any) -> str:
        return data.draw_string(self.intervals, min_size=1, max_size=1)

_nonempty_names = (
    'capitalize',
    'expandtabs',
    'join',
    'lower',
    'rsplit',
    'split',
    'splitlines',
    'swapcase',
    'title',
    'upper',
)
_nonempty_and_content_names = (
    'islower',
    'isupper',
    'isalnum',
    'isalpha',
    'isascii',
    'isdigit',
    'isspace',
    'istitle',
    'lstrip',
    'rstrip',
    'strip',
)

class TextStrategy(ListStrategy):
    def do_draw(self, data: Any) -> str:
        elems: Any = unwrap_strategies(self.element_strategy)
        if isinstance(elems, OneCharStringStrategy):
            return data.draw_string(
                elems.intervals,
                min_size=self.min_size,
                max_size=COLLECTION_DEFAULT_MAX_SIZE if self.max_size == float('inf') else self.max_size,
            )
        return ''.join(super().do_draw(data))

    def __repr__(self) -> str:
        args: list[str] = []
        if repr(self.element_strategy) != 'characters()':
            args.append(repr(self.element_strategy))
        if self.min_size:
            args.append(f'min_size={self.min_size}')
        if self.max_size < float('inf'):
            args.append(f'max_size={self.max_size}')
        return f'text({", ".join(args)})'

    _nonempty_filters: Tuple[Any, ...] = (
        *ListStrategy._nonempty_filters,
        str,
        str.casefold,
        str.encode,
        *(getattr(str, n) for n in _nonempty_names)
    )
    _nonempty_and_content_filters: Tuple[Any, ...] = (
        str.isdecimal,
        str.isnumeric,
        *(getattr(str, n) for n in _nonempty_and_content_names)
    )

    def filter(self, condition: Any) -> SearchStrategy:
        elems: Any = unwrap_strategies(self.element_strategy)
        if condition is str.isidentifier and self.max_size >= 1 and isinstance(elems, OneCharStringStrategy):
            from hypothesis.strategies import builds, nothing
            id_start, id_continue = _identifier_characters()
            if not elems.intervals & id_start:
                return nothing()
            return builds(
                '{}{}'.format,
                OneCharStringStrategy(elems.intervals & id_start),
                TextStrategy(
                    OneCharStringStrategy(elems.intervals & id_continue),
                    min_size=max(0, self.min_size - 1),
                    max_size=self.max_size - 1,
                ),
            ).filter(str.isidentifier)
        if (new := _string_filter_rewrite(self, str, condition)) is not None:
            return new
        return super().filter(condition)

def _string_filter_rewrite(
    self: SearchStrategy, kind: Union[type(str), type(bytes)], condition: Any
) -> Optional[SearchStrategy]:
    if condition in (kind.lower, kind.title, kind.upper):
        k: str = kind.__name__
        warnings.warn(
            f'You applied {k}.{condition.__name__} as a filter, but this allows all nonempty strings!  Did you mean {k}.is{condition.__name__}?',
            HypothesisWarning,
            stacklevel=2,
        )
    pattern: Any = getattr(condition, '__self__', None)
    if (
        (kind is bytes or isinstance(unwrap_strategies(self.element_strategy), OneCharStringStrategy))
        and isinstance(pattern, re.Pattern)
        and isinstance(pattern.pattern, kind)
    ):
        from hypothesis.strategies._internal.regex import regex_strategy
        if condition.__name__ == 'match':
            caret, close = ('^(?:', ')') if kind is str else (b'^(?:', b')')
            pattern = re.compile(caret + pattern.pattern + close, flags=pattern.flags)
            condition = pattern.search
        if condition.__name__ in ('search', 'findall', 'fullmatch'):
            s: SearchStrategy = regex_strategy(
                pattern,
                fullmatch=condition.__name__ == 'fullmatch',
                alphabet=self.element_strategy if kind is str else None,
            )
            if self.min_size > 0:
                s = s.filter(partial(min_len, self.min_size))
            if self.max_size < 1e309:
                s = s.filter(partial(max_len, self.max_size))
            return s
        elif condition.__name__ in ('finditer', 'scanner'):
            warnings.warn(
                f'You applied {pretty(condition)} as a filter, but this allows any string at all!  Did you mean .findall ?',
                HypothesisWarning,
                stacklevel=3,
            )
            return self
        elif condition.__name__ == 'split':
            warnings.warn(
                f'You applied {pretty(condition)} as a filter, but this allows any nonempty string!  Did you mean .search ?',
                HypothesisWarning,
                stacklevel=3,
            )
            return self.filter(bool)
    if condition in self._nonempty_and_content_filters and self.max_size >= 1:
        self = copy.copy(self)
        self.min_size = max(1, self.min_size)
        return ListStrategy.filter(self, condition)
    return None

_PROPLIST: str = (
    "\n# ================================================\n\n1885..1886    ; Other_ID_Start # Mn   [2] MONGOLIAN LETTER ALI GALI BALUDA..MONGOLIAN LETTER ALI GALI THREE BALUDA\n"
    "2118          ; Other_ID_Start # Sm       SCRIPT CAPITAL P\n"
    "212E          ; Other_ID_Start # So       ESTIMATED SYMBOL\n"
    "309B..309C    ; Other_ID_Start # Sk   [2] KATAKANA-HIRAGANA VOICED SOUND MARK..KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK\n\n"
    "# Total code points: 6\n\n"
    "# ================================================\n\n00B7          ; Other_ID_Continue # Po       MIDDLE DOT\n"
    "0387          ; Other_ID_Continue # Po       GREEK ANO TELEIA\n"
    "1369..1371    ; Other_ID_Continue # No   [9] ETHIOPIC DIGIT ONE..ETHIOPIC DIGIT NINE\n"
    "19DA          ; Other_ID_Continue # No       NEW TAI LUE THAM DIGIT ONE\n\n"
    "# Total code points: 12\n"
)

@lru_cache
def _identifier_characters() -> Tuple[IntervalSet, IntervalSet]:
    """See https://docs.python.org/3/reference/lexical_analysis.html#identifiers"""
    chars: dict[str, str] = {'Other_ID_Start': '', 'Other_ID_Continue': ''}
    for line in _PROPLIST.splitlines():
        if (m := re.match('([0-9A-F.]+) +; (\\w+) # ', line)):
            codes, prop = m.groups()
            span = range(int(codes[:4], base=16), int(codes[-4:], base=16) + 1)
            chars[prop] += ''.join(chr(x) for x in span)
    id_start: IntervalSet = charmap.query(
        categories=('Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nl'),
        include_characters='_' + chars['Other_ID_Start'],
    )
    id_start -= IntervalSet.from_string('ͺำຳⸯ゛゜ﱞﱟﱠﱡﱢﱣﷺﷻﹰﹲﹴﹶﹸﹺﹼﹾﾞﾟ')
    id_continue: IntervalSet = id_start | charmap.query(
        categories=('Mn', 'Mc', 'Nd', 'Pc'),
        include_characters=chars['Other_ID_Continue'],
    )
    return (id_start, id_continue)

class BytesStrategy(SearchStrategy):
    def __init__(self, min_size: int, max_size: Optional[int]) -> None:
        self.min_size: int = min_size
        self.max_size: int = max_size if max_size is not None else COLLECTION_DEFAULT_MAX_SIZE

    def do_draw(self, data: Any) -> bytes:
        return data.draw_bytes(self.min_size, self.max_size)

    _nonempty_filters: Tuple[Any, ...] = (
        *ListStrategy._nonempty_filters,
        bytes,
        *(getattr(bytes, n) for n in _nonempty_names)
    )
    _nonempty_and_content_filters: Tuple[Any, ...] = (
        *(getattr(bytes, n) for n in _nonempty_and_content_names),
    )

    def filter(self, condition: Any) -> SearchStrategy:
        if (new := _string_filter_rewrite(self, bytes, condition)) is not None:
            return new
        return ListStrategy.filter(self, condition)