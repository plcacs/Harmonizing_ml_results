def _choice(num_words: int, num_samples: int) -> Tuple[np.ndarray, int]:
    ...

class SampledSoftmaxLoss(torch.nn.Module):
    def __init__(self, num_words: int, embedding_dim: int, num_samples: int, sparse: bool = False, unk_id: int = None, use_character_inputs: bool = True, use_fast_sampler: bool = False):
        ...

    def initialize_num_words(self):
        ...

    def forward(self, embeddings: torch.Tensor, targets: torch.Tensor, target_token_embedding: torch.Tensor = None) -> torch.Tensor:
        ...

    def _forward_train(self, embeddings: torch.Tensor, targets: torch.Tensor, target_token_embedding: torch.Tensor) -> torch.Tensor:
        ...

    def _forward_eval(self, embeddings: torch.Tensor, targets: torch.Tensor) -> torch.Tensor:
        ...

    def log_uniform_candidate_sampler(self, targets: torch.Tensor, choice_func=_choice) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        ...
