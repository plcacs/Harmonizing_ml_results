from pathlib import Path
from typing import Set, List, Tuple

def _get_sdist_name(name: str, version: str) -> str:
    ...

def _safe_parse_requirements(requirements_txt: str) -> Set[str]:
    ...

def call_pipeline_create(self, cli: Any, metadata: Any) -> None:
    ...

def call_micropkg_package(self, cli: Any, metadata: Any) -> None:
    ...

def call_pipeline_delete(self, cli: Any, metadata: Any) -> None:
    ...

def call_micropkg_pull(self, cli: Any, metadata: Any, repo_path: Path) -> None:
    ...

def test_existing_complex_project_requirements_txt(self, fake_project_cli: Any, fake_metadata: Any, fake_package_path: Path, fake_repo_path: Path) -> None:
    ...

def test_existing_project_requirements_txt(self, fake_project_cli: Any, fake_metadata: Any, fake_package_path: Path, fake_repo_path: Path) -> None:
    ...

def test_missing_project_requirements_txt(self, fake_project_cli: Any, fake_metadata: Any, fake_package_path: Path, fake_repo_path: Path) -> None:
    ...

def test_no_requirements(self, fake_project_cli: Any, fake_metadata: Any, fake_repo_path: Path) -> None:
    ...

def test_all_requirements_already_covered(self, fake_project_cli: Any, fake_metadata: Any, fake_repo_path: Path, fake_package_path: Path) -> None:
    ...

def test_no_pipeline_requirements_txt(self, fake_project_cli: Any, fake_metadata: Any, fake_repo_path: Path) -> None:
    ...

def test_empty_pipeline_requirements_txt(self, fake_project_cli: Any, fake_metadata: Any, fake_package_path: Path, fake_repo_path: Path) -> None:
    ...

def test_complex_requirements(self, requirement: str, fake_project_cli: Any, fake_metadata: Any, fake_package_path: Path) -> None:
    ...
