from typing import Any, Dict, List, Tuple, Union
from raiden.constants import RoutingMode
from raiden.network.pathfinding import PFSConfig, PFSInfo, PFSProxy
from raiden.transfer.state import RouteState
from raiden.utils.typing import Address, BlockNumber, ChainID, PaymentAmount, TokenAmount, TokenNetworkAddress

def assert_checksum_address_in_url(url: str) -> None:
    ...

def make_address_metadata(signer: Any) -> Dict[str, Any]:
    ...

def create_square_network_topology(token_network_state: Any, our_address: Address) -> Tuple[Any, List[Address], Any]:
    ...

def get_best_routes_with_iou_request_mocked(chain_state: Any, token_network_state: Any, one_to_n_address: Address, from_address: Address, to_address: Address, amount: PaymentAmount, our_address_metadata: Dict[str, Any], iou_json_data: Dict[str, Any] = None) -> Tuple[List[RouteState], Union[None, Any]]:
    ...

def happy_path_fixture(chain_state: Any, token_network_state: Any, our_address: Address) -> Tuple[List[Address], Any, Any, Any, Any]:
    ...

def test_routing_mocked_pfs_happy_path(happy_path_fixture: Tuple[List[Address], Any, Any, Any, Any], one_to_n_address: Address, our_signer: Any) -> None:
    ...

def test_routing_mocked_pfs_happy_path_with_updated_iou(happy_path_fixture: Tuple[List[Address], Any, Any, Any, Any], one_to_n_address: Address, our_signer: Any) -> None:
    ...

def test_routing_mocked_pfs_request_error(chain_state: Any, token_network_state: Any, one_to_n_address: Address, our_signer: Any) -> None:
    ...

def test_routing_mocked_pfs_bad_http_code(chain_state: Any, token_network_state: Any, one_to_n_address: Address, our_signer: Any) -> None:
    ...

def test_routing_mocked_pfs_invalid_json(chain_state: Any, token_network_state: Any, one_to_n_address: Address, our_signer: Any) -> None:
    ...

def test_routing_mocked_pfs_invalid_json_structure(chain_state: Any, one_to_n_address: Address, token_network_state: Any, our_signer: Any) -> None:
    ...

def test_routing_mocked_pfs_unavailable_peer(chain_state: Any, token_network_state: Any, one_to_n_address: Address, our_signer: Any) -> None:
    ...

def test_get_and_update_iou(one_to_n_address: Address) -> None:
    ...

def test_get_pfs_iou(one_to_n_address: Address) -> None:
    ...

def test_make_iou() -> None:
    ...

def test_update_iou() -> None:
    ...

def assert_failed_pfs_request(paths_args: Dict[str, Any], responses: List[Dict[str, Any]], status_codes: Tuple[int, int] = (400, 400), expected_requests: int = MAX_PATHS_QUERY_ATTEMPTS, expected_get_iou_requests: Union[None, int] = None, expected_success: bool = False, exception_type: Any = ServiceRequestFailed) -> None:
    ...

def test_routing_in_direct_channel(happy_path_fixture: Tuple[List[Address], Any, Any, Any, Any], our_signer: Any, one_to_n_address: Address) -> None:
    ...

def test_query_paths_with_second_try(query_paths_args: Dict[str, Any], valid_response_json: Dict[str, Any]) -> None:
    ...

def test_query_paths_with_scrapped_iou(query_paths_args: Dict[str, Any], valid_response_json: Dict[str, Any]) -> None:
    ...

def test_query_paths_with_unrecoverable_pfs_error(query_paths_args: Dict[str, Any]) -> None:
    ...

def test_insufficient_payment(query_paths_args: Dict[str, Any], valid_response_json: Dict[str, Any]) -> None:
    ...

def test_query_paths_with_multiple_errors(query_paths_args: Dict[str, Any]) -> None:
    ...

def test_post_pfs_feedback() -> None:
    ...

def test_no_iou_when_pfs_price_0(query_paths_args: Dict[str, Any]) -> None:
    ...

def test_two_parallel_queries(query_paths_args: Dict[str, Any]) -> None:
    ...

def test_make_route_state_address_to_metadata_serialization_regression() -> None:
    ...
