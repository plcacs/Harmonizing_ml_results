from typing import List, Union

def make_data() -> List[Union[int, float]]:
    ...

def make_float_data() -> List[Union[float, float]]:
    ...

def make_bool_data() -> List[Union[bool, float]]:
    ...

def data(dtype) -> pd.array:
    ...

def data_for_twos(dtype) -> pd.array:
    ...

def data_missing(dtype) -> pd.array:
    ...

def data_for_sorting(dtype) -> pd.array:
    ...

def data_missing_for_sorting(dtype) -> pd.array:
    ...

def na_cmp() -> callable:
    ...

def data_for_grouping(dtype) -> pd.array:
    ...

class TestMaskedArrays(base.ExtensionTests):

    def test_map(self, data_missing, na_action: Union[None, str]):
        ...

    def test_map_na_action_ignore(self, data_missing_for_sorting):
        ...

    def _get_expected_exception(self, op_name: str, obj, other):
        ...

    def _cast_pointwise_result(self, op_name: str, obj, other, pointwise_result) -> np.array:
        ...

    def test_divmod_series_array(self, data, data_for_twos):
        ...

    def test_combine_le(self, data_repeated):
        ...

    def _supports_reduction(self, ser, op_name: str) -> bool:
        ...

    def check_reduce(self, ser, op_name: str, skipna: bool):
        ...

    def _get_expected_reduction_dtype(self, arr, op_name: str, skipna: bool) -> str:
        ...

    def _supports_accumulation(self, ser, op_name: str) -> bool:
        ...

    def check_accumulate(self, ser, op_name: str, skipna: bool):
        ...

class Test2DCompat(base.Dim2CompatTests):
    ...
