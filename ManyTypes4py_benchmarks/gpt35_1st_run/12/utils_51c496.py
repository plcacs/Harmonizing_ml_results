from os import PathLike
from typing import IO, Dict, List, Any, Tuple, Iterator, BinaryIO, Text
from typing import Optional, Union, MutableMapping, Callable

OptInt = Optional[int]
OptBytes = Optional[bytes]
EnvVars = MutableMapping
StrPath = Union[str, PathLike]

class AbortedError(Exception):
    pass

def to_cfn_resource_name(name: str) -> str:
    ...

def remove_stage_from_deployed_values(key: str, filename: str) -> None:
    ...

def record_deployed_values(deployed_values: Dict[str, Any], filename: str) -> None:
    ...

def serialize_to_json(data: Any) -> str:
    ...

class ChaliceZipFile(zipfile.ZipFile):
    ...

    def __init__(self, *args, osutils: OSUtils, **kwargs):
        ...

    def write(self, filename: str, arcname: str = None, compress_type: int = None, compresslevel: int = None) -> None:
        ...

def create_zip_file(source_dir: str, outfile: str) -> None:
    ...

class OSUtils:
    ...

    def environ(self) -> EnvVars:
        ...

    def open(self, filename: str, mode: str) -> IO:
        ...

    def open_zip(self, filename: str, mode: str, compression: int = zipfile.ZIP_DEFLATED) -> ChaliceZipFile:
        ...

    def remove_file(self, filename: str) -> None:
        ...

    def file_exists(self, filename: str) -> bool:
        ...

    def get_file_contents(self, filename: str, binary: bool = True, encoding: str = 'utf-8') -> str:
        ...

    def set_file_contents(self, filename: str, contents: str, binary: bool = True) -> None:
        ...

    def extract_zipfile(self, zipfile_path: str, unpack_dir: str) -> None:
        ...

    def extract_tarfile(self, tarfile_path: str, unpack_dir: str) -> None:
        ...

    def directory_exists(self, path: str) -> bool:
        ...

    def get_directory_contents(self, path: str) -> List[str]:
        ...

    def makedirs(self, path: str) -> None:
        ...

    def dirname(self, path: str) -> str:
        ...

    def abspath(self, path: str) -> str:
        ...

    def joinpath(self, *args: str) -> str:
        ...

    def walk(self, path: str, followlinks: bool = False) -> Iterator[Tuple[str, List[str], List[str]]]:
        ...

    def copytree(self, source: str, destination: str) -> None:
        ...

    def rmtree(self, directory: str) -> None:
        ...

    def copy(self, source: str, destination: str) -> None:
        ...

    def move(self, source: str, destination: str) -> None:
        ...

    def mtime(self, path: str) -> float:
        ...

    def stat(self, path: str) -> os.stat_result:
        ...

    def normalized_filename(self, path: str) -> str:
        ...

    @property
    def pipe(self) -> int:
        ...

    def basename(self, path: str) -> str:
        ...

    @contextlib.contextmanager
    def tempdir(self) -> Iterator[str]:
        ...

    def popen(self, command: List[str], stdout: Optional[int] = None, stderr: Optional[int] = None, env: Optional[EnvVars] = None) -> subprocess.Popen:
        ...

class UI:
    ...

    def __init__(self, out: IO = None, err: IO = None, confirm: Callable = None):
        ...

    def write(self, msg: str) -> None:
        ...

    def error(self, msg: str) -> None:
        ...

    def confirm(self, msg: str, default: bool = False, abort: bool = False) -> bool:
        ...

class PipeReader:
    ...

    def __init__(self, stream: IO):
        ...

    def read(self) -> Optional[str]:
        ...

class TimestampConverter:
    ...

    def __init__(self, now: Optional[Callable[[], datetime]] = None):
        ...

    def timestamp_to_datetime(self, timestamp: str) -> datetime:
        ...

    def _relative_timestamp_to_datetime(self, amount: int, unit: str) -> datetime:
        ...

    def parse_iso8601_timestamp(self, timestamp: str) -> datetime:
        ...
