from random import Random
from typing import Callable, Dict, List
from eth2spec import Spec  # Assuming Spec is a class

def _randomize_deposit_state(spec: Spec, state: State, stats: Dict[str, int]) -> Dict[str, List]:
    ...

def randomize_state(spec: Spec, state: State, stats: Dict[str, int], exit_fraction: float = 0.1, slash_fraction: float = 0.1) -> Dict[str, List]:
    ...

def randomize_state_altair(spec: Spec, state: State, stats: Dict[str, int], exit_fraction: float = 0.1, slash_fraction: float = 0.1) -> Dict[str, List]:
    ...

def randomize_state_bellatrix(spec: Spec, state: State, stats: Dict[str, int], exit_fraction: float = 0.1, slash_fraction: float = 0.1) -> Dict[str, List]:
    ...

def randomize_state_capella(spec: Spec, state: State, stats: Dict[str, int], exit_fraction: float = 0.1, slash_fraction: float = 0.1) -> Dict[str, List]:
    ...

def randomize_state_deneb(spec: Spec, state: State, stats: Dict[str, int], exit_fraction: float = 0.1, slash_fraction: float = 0.1) -> Dict[str, List]:
    ...

def randomize_state_electra(spec: Spec, state: State, stats: Dict[str, int], exit_fraction: float = 0.1, slash_fraction: float = 0.1) -> Dict[str, List]:
    ...

def randomize_state_fulu(spec: Spec, state: State, stats: Dict[str, int], exit_fraction: float = 0.1, slash_fraction: float = 0.1) -> Dict[str, List]:
    ...

def epochs_until_leak(spec: Spec) -> int:
    ...

def epochs_for_shard_committee_period(spec: Spec) -> int:
    ...

def last_slot_in_epoch(spec: Spec) -> int:
    ...

def random_slot_in_epoch(spec: Spec, rng: Random = Random(1336)) -> int:
    ...

def penultimate_slot_in_epoch(spec: Spec) -> int:
    ...

def no_block(spec: Spec, pre_state: State, signed_blocks: List, scenario_state: Dict) -> None:
    ...

def _warn_if_empty_operations(block: Block) -> None:
    ...

def _pull_deposits_from_scenario_state(spec: Spec, scenario_state: Dict, existing_block_count: int) -> List:
    ...

def random_block(spec: Spec, state: State, signed_blocks: List, scenario_state: Dict) -> Block:
    ...

def random_block_altair_with_cycling_sync_committee_participation(spec: Spec, state: State, signed_blocks: List, scenario_state: Dict) -> Block:
    ...

def random_block_bellatrix(spec: Spec, state: State, signed_blocks: List, scenario_state: Dict, rng: Random = Random(3456)) -> Block:
    ...

def random_block_capella(spec: Spec, state: State, signed_blocks: List, scenario_state: Dict, rng: Random = Random(3456)) -> Block:
    ...

def random_block_deneb(spec: Spec, state: State, signed_blocks: List, scenario_state: Dict, rng: Random = Random(3456)) -> Block:
    ...

def random_block_electra(spec: Spec, state: State, signed_blocks: List, scenario_state: Dict, rng: Random = Random(3456)) -> Block:
    ...

def random_block_fulu(spec: Spec, state: State, signed_blocks: List, scenario_state: Dict, rng: Random = Random(3456)) -> Block:
    ...

def no_op_validation(spec: Spec, state: State) -> bool:
    ...

def validate_is_leaking(spec: Spec, state: State) -> bool:
    ...

def validate_is_not_leaking(spec: Spec, state: State) -> bool:
    ...

def with_validation(transition: Callable, validation: Callable) -> Dict:
    ...

def no_op_transition() -> Dict:
    ...

def epoch_transition(n: int = 0) -> Dict:
    ...

def slot_transition(n: int = 0) -> Dict:
    ...

def transition_to_leaking() -> Dict:
    ...

def transition_without_leak() -> Dict:
    ...

def transition_with_random_block(block_randomizer: Callable) -> Dict:
    ...

def _randomized_scenario_setup(state_randomizer: Callable) -> List[Tuple[Callable, Callable]]:
    ...

def _resolve_ref(ref: str) -> Callable:
    ...

def _iter_temporal(spec: Spec, description: str) -> Iterable[int]:
    ...

def _compute_statistics(scenario: Dict) -> Dict:
    ...

def run_generated_randomized_test(spec: Spec, state: State, scenario: Dict) -> Iterable[Tuple[str, Union[State, List]]]:
    ...
