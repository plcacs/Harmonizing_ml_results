def interesting_origin(n: Optional[int] = None) -> InterestingOrigin:
    ...

def run_to_data(f) -> ConjectureData:
    ...

def run_to_nodes(f) -> List[ChoiceNode]:
    ...

def buffer_size_limit(n: int):
    ...

def shrinking_from(start: ChoiceNode) -> Shrinker:
    ...

def fresh_data(*, random: Optional[Random] = None, observer: Optional[Observer] = None) -> ConjectureData:
    ...

def clamped_shrink_towards(kwargs: Dict[str, Any]) -> Any:
    ...

def integer_weights(min_value: Optional[int] = None, max_value: Optional[int] = None) -> Dict[int, float]:
    ...

def integer_kwargs(use_min_value: Optional[bool] = None, use_max_value: Optional[bool] = None, use_shrink_towards: bool = False, use_weights: bool = False, use_forced: bool = False) -> Dict[str, Any]:
    ...

def _collection_kwargs(forced: Optional[List[Any]], use_min_size: Optional[bool] = None, use_max_size: Optional[bool] = None) -> Dict[str, Any]:
    ...

def string_kwargs(use_min_size: Optional[bool] = None, use_max_size: Optional[bool] = None, use_forced: bool = False) -> Dict[str, Any]:
    ...

def bytes_kwargs(use_min_size: Optional[bool] = None, use_max_size: Optional[bool] = None, use_forced: bool = False) -> Dict[str, Any]:
    ...

def float_kwargs(use_min_value: Optional[bool] = None, use_max_value: Optional[bool] = None, use_forced: bool = False) -> Dict[str, Any]:
    ...

def boolean_kwargs(use_forced: bool = False) -> Dict[str, Any]:
    ...

def kwargs_strategy(choice_type: str, strategy_kwargs: Optional[Dict[str, Any]] = None, use_forced: bool = False) -> Callable:
    ...

def choice_types_kwargs(strategy_kwargs: Optional[Dict[str, Any]] = None, use_forced: bool = False) -> Callable:
    ...

def draw_value(choice_type: str, kwargs: Dict[str, Any]) -> Any:
    ...

def nodes(was_forced: Optional[bool] = None, choice_types: Optional[List[str]] = None) -> ChoiceNode:
    ...

def ir(*values) -> Tuple[ChoiceNode, ...]:
    ...

def float_kw(min_value: float = -math.inf, max_value: float = math.inf, allow_nan: bool = True, smallest_nonzero_magnitude: float = SMALLEST_SUBNORMAL) -> Dict[str, Any]:
    ...

def integer_kw(min_value: Optional[int] = None, max_value: Optional[int] = None, weights: Optional[Dict[int, float]] = None, shrink_towards: int = 0) -> Dict[str, Any]:
    ...

def string_kw(intervals: IntervalSet, min_size: int = 0, max_size: int = COLLECTION_DEFAULT_MAX_SIZE) -> Dict[str, Any]:
    ...
