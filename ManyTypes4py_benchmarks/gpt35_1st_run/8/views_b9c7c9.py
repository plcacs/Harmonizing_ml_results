from faust.types import AppT, ModelT
from faust.types.web import ViewDecorator, ViewHandlerFun
from yarl import URL
from .base import Request, Response, Web
from .exceptions import WebError

class View:
    """Web view (HTTP endpoint)."""
    ServerError: Type[exceptions.ServerError]
    ValidationError: Type[exceptions.ValidationError]
    ParseError: Type[exceptions.ParseError]
    NotAuthenticated: Type[exceptions.NotAuthenticated]
    PermissionDenied: Type[exceptions.PermissionDenied]
    NotFound: Type[exceptions.NotFound]

    @classmethod
    def from_handler(cls, fun: ViewHandlerFun) -> Type['View']: ...

    def __init__(self, app: AppT, web: Web) -> None: ...

    def __post_init__(self) -> None: ...

    async def __call__(self, request: Request) -> Response: ...

    async def dispatch(self, request: Request) -> Response: ...

    async def on_request_error(self, request: Request, exc: WebError) -> Response: ...

    def path_for(self, view_name: str, **kwargs: Any) -> str: ...

    def url_for(self, view_name: str, _base_url: Optional[URL] = None, **kwargs: Any) -> URL: ...

    async def head(self, request: Request, **kwargs: Any) -> Response: ...

    async def get(self, request: Request, **kwargs: Any) -> Response: ...

    async def post(self, request: Request, **kwargs: Any) -> Response: ...

    async def put(self, request: Request, **kwargs: Any) -> Response: ...

    async def patch(self, request: Request, **kwargs: Any) -> Response: ...

    async def delete(self, request: Request, **kwargs: Any) -> Response: ...

    async def options(self, request: Request, **kwargs: Any) -> Response: ...

    async def search(self, request: Request, **kwargs: Any) -> Response: ...

    def text(self, value: str, *, content_type: Optional[str] = None, status: int = 200, reason: Optional[str] = None, headers: Optional[Mapping[str, str]] = None) -> Response: ...

    def html(self, value: str, *, content_type: Optional[str] = None, status: int = 200, reason: Optional[str] = None, headers: Optional[Mapping[str, str]] = None) -> Response: ...

    def json(self, value: Any, *, content_type: Optional[str] = None, status: int = 200, reason: Optional[str] = None, headers: Optional[Mapping[str, str]] = None) -> Response: ...

    def bytes(self, value: _bytes, *, content_type: Optional[str] = None, status: int = 200, reason: Optional[str] = None, headers: Optional[Mapping[str, str]] = None) -> Response: ...

    async def read_request_content(self, request: Request) -> _bytes: ...

    def bytes_to_response(self, s: _bytes) -> Response: ...

    def response_to_bytes(self, response: Response) -> _bytes: ...

    def route(self, pattern: str, handler: Callable) -> Callable: ...

    def notfound(self, reason: str = 'Not Found', **kwargs: Any) -> Response: ...

    def error(self, status: int, reason: str, **kwargs: Any) -> Response: ...

def takes_model(Model: Type[ModelT]) -> ViewDecorator: ...

def gives_model(Model: Type[ModelT]) -> ViewDecorator: ...
