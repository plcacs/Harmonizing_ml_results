from typing import Any, ClassVar, Literal, Optional, TypeVar, Union, overload
from prefect.client.schemas import objects
from prefect.server.utilities.schemas.bases import IDBaseModel, PrefectBaseModel
from prefect.types._datetime import DateTime
from prefect.utilities.collections import AutoEnum

R = TypeVar('R')
_State = TypeVar('_State', bound='State')

class StateType(AutoEnum):
    SCHEDULED: Literal['SCHEDULED']
    PENDING: Literal['PENDING']
    RUNNING: Literal['RUNNING']
    COMPLETED: Literal['COMPLETED']
    FAILED: Literal['FAILED']
    CANCELLED: Literal['CANCELLED']
    CRASHED: Literal['CRASHED']
    PAUSED: Literal['PAUSED']
    CANCELLING: Literal['CANCELLING']

class CountByState(PrefectBaseModel):
    COMPLETED: int
    PENDING: int
    RUNNING: int
    FAILED: int
    CANCELLED: int
    CRASHED: int
    PAUSED: int
    CANCELLING: int
    SCHEDULED: int

class StateDetails(PrefectBaseModel):
    flow_run_id: Optional[UUID]
    task_run_id: Optional[UUID]
    child_flow_run_id: Optional[UUID]
    scheduled_time: Optional[DateTime]
    cache_key: Optional[str]
    cache_expiration: Optional[DateTime]
    deferred: bool
    untrackable_result: bool
    pause_timeout: Optional[DateTime]
    pause_reschedule: bool
    pause_key: Optional[str]
    run_input_keyset: Optional[Any]
    refresh_cache: Optional[Any]
    retriable: Optional[Any]
    transition_id: Optional[Any]
    task_parameters_id: Optional[Any]
    traceparent: Optional[Any]

class StateBaseModel(IDBaseModel):
    def orm_dict(self, *args, **kwargs) -> dict: ...

class State(StateBaseModel):
    model_config: ClassVar[ConfigDict]
    name: Optional[str]
    timestamp: DateTime
    message: Optional[str]
    data: Optional[Any]
    state_details: StateDetails

    @classmethod
    def from_orm_without_result(cls, orm_state: Union[ORMFlowRunState, ORMTaskRunState], with_data: Any = None) -> 'State': ...

    @model_validator(mode='after')
    def default_name_from_type(self) -> 'State': ...

    @model_validator(mode='after')
    def default_scheduled_start_time(self) -> 'State': ...

    def is_scheduled(self) -> bool: ...
    def is_pending(self) -> bool: ...
    def is_running(self) -> bool: ...
    def is_completed(self) -> bool: ...
    def is_failed(self) -> bool: ...
    def is_crashed(self) -> bool: ...
    def is_cancelled(self) -> bool: ...
    def is_cancelling(self) -> bool: ...
    def is_final(self) -> bool: ...
    def is_paused(self) -> bool: ...
    def fresh_copy(self, **kwargs) -> 'State': ...

    @overload
    def result(self, raise_on_failure: bool = ..., fetch: Any = ...) -> Any: ...

    def to_state_create(self) -> 'StateCreate': ...

    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...

def Scheduled(scheduled_time: Optional[DateTime] = None, cls: Type[State] = State, **kwargs: Any) -> State: ...
def Completed(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Running(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Failed(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Crashed(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Cancelling(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Cancelled(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Pending(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Paused(cls: Type[State] = State, timeout_seconds: Optional[int] = None, pause_expiration_time: Optional[DateTime] = None, reschedule: bool = False, pause_key: Optional[str] = None, **kwargs: Any) -> State: ...
def Suspended(cls: Type[State] = State, timeout_seconds: Optional[int] = None, pause_expiration_time: Optional[DateTime] = None, pause_key: Optional[str] = None, **kwargs: Any) -> State: ...
def AwaitingRetry(cls: Type[State] = State, scheduled_time: Optional[DateTime] = None, **kwargs: Any) -> State: ...
def Retrying(cls: Type[State] = State, **kwargs: Any) -> State: ...
def Late(cls: Type[State] = State, scheduled_time: Optional[DateTime] = None, **kwargs: Any) -> State: ...
