# This module is a collection of testing helpers for validating the
# schema of "events" sent by Zulip's server-to-client push system.
#
# By policy, every event generated by Zulip's API should be validated
# by a test in test_events.py with a schema checker here.
#
# See https://zulip.readthedocs.io/en/latest/subsystems/events-system.html
from collections.abc import Callable
from pprint import PrettyPrinter
from typing import cast, Any, Literal, TypedDict, TypeVar, Union

from pydantic import BaseModel

from zerver.lib.event_types import (
    AllowMessageEditingData,
    AuthenticationData,
    BaseEvent,
    BotServicesEmbedded,
    BotServicesOutgoing,
    EventAlertWords,
    EventAttachmentAdd,
    EventAttachmentRemove,
    EventAttachmentUpdate,
    EventCustomProfileFields,
    EventDefaultStreamGroups,
    EventDefaultStreams,
    EventDeleteMessage,
    EventDirectMessage,
    EventDraftsAdd,
    EventDraftsRemove,
    EventDraftsUpdate,
    EventHasZoomToken,
    EventHeartbeat,
    EventInvitesChanged,
    EventMessage,
    EventMutedTopics,
    EventMutedUsers,
    EventOnboardingSteps,
    EventPresence,
    EventReactionAdd,
    EventReactionRemove,
    EventRealmBotAdd,
    EventRealmBotDelete,
    EventRealmBotUpdate,
    EventRealmDeactivated,
    EventRealmDomainsAdd,
    EventRealmDomainsChange,
    EventRealmDomainsRemove,
    EventRealmEmojiUpdate,
    EventRealmExport,
    EventRealmExportConsent,
    EventRealmLinkifiers,
    EventRealmPlaygrounds,
    EventRealmUpdate,
    EventRealmUpdateDict,
    EventRealmUserAdd,
    EventRealmUserRemove,
    EventRealmUserSettingsDefaultsUpdate,
    EventRealmUserUpdate,
    EventRestart,
    EventSavedSnippetsAdd,
    EventSavedSnippetsRemove,
    EventScheduledMessagesAdd,
    EventScheduledMessagesRemove,
    EventScheduledMessagesUpdate,
    EventStreamCreate,
    EventStreamDelete,
    EventStreamUpdate,
    EventSubmessage,
    EventSubscriptionAdd,
    EventSubscriptionPeerAdd,
    EventSubscriptionPeerRemove,
    EventSubscriptionRemove,
    EventSubscriptionUpdate,
    EventTypingEditChannelMessageStart,
    EventTypingEditChannelMessageStop,
    EventTypingEditDirectMessageStart,
    EventTypingEditDirectMessageStop,
    EventTypingStart,
    EventTypingStop,
    EventUpdateDisplaySettings,
    EventUpdateGlobalNotifications,
    EventUpdateMessage,
    EventUpdateMessageFlagsAdd,
    EventUpdateMessageFlagsRemove,
    EventUserGroupAdd,
    EventUserGroupAddMembers,
    EventUserGroupAddSubgroups,
    EventUserGroupRemove,
    EventUserGroupRemoveMembers,
    EventUserGroupRemoveSubgroups,
    EventUserGroupUpdate,
    EventUserSettingsUpdate,
    EventUserStatus,
    EventUserTopic,
    EventWebReloadClient,
    GroupSettingUpdateData,
    IconData,
    LogoData,
    MessageContentEditLimitSecondsData,
    NightLogoData,
    PersonAvatarFields,
    PersonBotOwnerId,
    PersonCustomProfileField,
    PersonDeliveryEmail,
    PersonEmail,
    PersonFullName,
    PersonIsActive,
    PersonIsBillingAdmin,
    PersonRole,
    PersonTimezone,
    PlanTypeData,
)
from zerver.lib.topic import ORIG_TOPIC, TOPIC_NAME
from zerver.lib.types import AnonymousSettingGroupDict
from zerver.models import Realm, RealmUserDefault, Stream, UserProfile


def validate_with_model(data: dict[str, object], model: type[BaseModel]) -> None:
    allowed_fields = set(model.model_fields.keys())
    if not set(data.keys()).issubset(allowed_fields):  # nocoverage
        raise ValueError(f"Extra fields not allowed: {set(data.keys()) - allowed_fields}")

    model.model_validate(data, strict=True)


def make_checker(base_model: type[BaseEvent]) -> Callable[[str, dict[str, object]], None]:
    def f(label: str, event: dict[str, object]) -> None:
        try:
            validate_with_model(event, base_model)
        except Exception as e:  # nocoverage
            print(f"""
FAILURE:

The event below fails the check to make sure it has the
correct "shape" of data:

    {label}

Often this is a symptom that the following type definition
is either broken or needs to be updated due to other
changes that you have made:

    {base_model}

A traceback should follow to help you debug this problem.

Here is the event:
""")

            PrettyPrinter(indent=4).pprint(event)
            raise e

    return f


check_alert_words: Callable[[str, dict[str, object]], None] = make_checker(EventAlertWords)
check_attachment_add: Callable[[str, dict[str, object]], None] = make_checker(EventAttachmentAdd)
check_attachment_remove: Callable[[str, dict[str, object]], None] = make_checker(EventAttachmentRemove)
check_attachment_update: Callable[[str, dict[str, object]], None] = make_checker(EventAttachmentUpdate)
check_custom_profile_fields: Callable[[str, dict[str, object]], None] = make_checker(EventCustomProfileFields)
check_default_stream_groups: Callable[[str, dict[str, object]], None] = make_checker(EventDefaultStreamGroups)
check_default_streams: Callable[[str, dict[str, object]], None] = make_checker(EventDefaultStreams)
check_direct_message: Callable[[str, dict[str, object]], None] = make_checker(EventDirectMessage)
check_draft_add: Callable[[str, dict[str, object]], None] = make_checker(EventDraftsAdd)
check_draft_remove: Callable[[str, dict[str, object]], None] = make_checker(EventDraftsRemove)
check_draft_update: Callable[[str, dict[str, object]], None] = make_checker(EventDraftsUpdate)
check_heartbeat: Callable[[str, dict[str, object]], None] = make_checker(EventHeartbeat)
check_invites_changed: Callable[[str, dict[str, object]], None] = make_checker(EventInvitesChanged)
check_message: Callable[[str, dict[str, object]], None] = make_checker(EventMessage)
check_muted_topics: Callable[[str, dict[str, object]], None] = make_checker(EventMutedTopics)
check_muted_users: Callable[[str, dict[str, object]], None] = make_checker(EventMutedUsers)
check_onboarding_steps: Callable[[str, dict[str, object]], None] = make_checker(EventOnboardingSteps)
check_reaction_add: Callable[[str, dict[str, object]], None] = make_checker(EventReactionAdd)
check_reaction_remove: Callable[[str, dict[str, object]], None] = make_checker(EventReactionRemove)
check_realm_bot_delete: Callable[[str, dict[str, object]], None] = make_checker(EventRealmBotDelete)
check_realm_deactivated: Callable[[str, dict[str, object]], None] = make_checker(EventRealmDeactivated)
check_realm_domains_add: Callable[[str, dict[str, object]], None] = make_checker(EventRealmDomainsAdd)
check_realm_domains_change: Callable[[str, dict[str, object]], None] = make_checker(EventRealmDomainsChange)
check_realm_domains_remove: Callable[[str, dict[str, object]], None] = make_checker(EventRealmDomainsRemove)
check_realm_export_consent: Callable[[str, dict[str, object]], None] = make_checker(EventRealmExportConsent)
check_realm_linkifiers: Callable[[str, dict[str, object]], None] = make_checker(EventRealmLinkifiers)
check_realm_playgrounds: Callable[[str, dict[str, object]], None] = make_checker(EventRealmPlaygrounds)
check_realm_user_add: Callable[[str, dict[str, object]], None] = make_checker(EventRealmUserAdd)
check_realm_user_remove: Callable[[str, dict[str, object]], None] = make_checker(EventRealmUserRemove)
check_restart: Callable[[str, dict[str, object]], None] = make_checker(EventRestart)
check_saved_snippets_add: Callable[[str, dict[str, object]], None] = make_checker(EventSavedSnippetsAdd)
check_saved_snippets_remove: Callable[[str, dict[str, object]], None] = make_checker(EventSavedSnippetsRemove)
check_scheduled_message_add: Callable[[str, dict[str, object]], None] = make_checker(EventScheduledMessagesAdd)
check_scheduled_message_remove: Callable[[str, dict[str, object]], None] = make_checker(EventScheduledMessagesRemove)
check_scheduled_message_update: Callable[[str, dict[str, object]], None] = make_checker(EventScheduledMessagesUpdate)
check_stream_create: Callable[[str, dict[str, object]], None] = make_checker(EventStreamCreate)
check_stream_delete: Callable[[str, dict[str, object]], None] = make_checker(EventStreamDelete)
check_submessage: Callable[[str, dict[str, object]], None] = make_checker(EventSubmessage)
check_subscription_add: Callable[[str, dict[str, object]], None] = make_checker(EventSubscriptionAdd)
check_subscription_peer_add: Callable[[str, dict[str, object]], None] = make_checker(EventSubscriptionPeerAdd)
check_subscription_peer_remove: Callable[[str, dict[str, object]], None] = make_checker(EventSubscriptionPeerRemove)
check_subscription_remove: Callable[[str, dict[str, object]], None] = make_checker(EventSubscriptionRemove)
check_typing_start: Callable[[str, dict[str, object]], None] = make_checker(EventTypingStart)
check_typing_stop: Callable[[str, dict[str, object]], None] = make_checker(EventTypingStop)
check_typing_edit_channel_message_start: Callable[[str, dict[str, object]], None] = make_checker(EventTypingEditChannelMessageStart)
check_typing_edit_direct_message_start: Callable[[str, dict[str, object]], None] = make_checker(EventTypingEditDirectMessageStart)
check_typing_edit_channel_message_stop: Callable[[str, dict[str, object]], None] = make_checker(EventTypingEditChannelMessageStop)
check_typing_edit_direct_message_stop: Callable[[str, dict[str, object]], None] = make_checker(EventTypingEditDirectMessageStop)
check_update_message_flags_add: Callable[[str, dict[str, object]], None] = make_checker(EventUpdateMessageFlagsAdd)
check_update_message_flags_remove: Callable[[str, dict[str, object]], None] = make_checker(EventUpdateMessageFlagsRemove)
check_user_group_add: Callable[[str, dict[str, object]], None] = make_checker(EventUserGroupAdd)
check_user_group_add_members: Callable[[str, dict[str, object]], None] = make_checker(EventUserGroupAddMembers)
check_user_group_add_subgroups: Callable[[str, dict[str, object]], None] = make_checker(EventUserGroupAddSubgroups)
check_user_group_remove: Callable[[str, dict[str, object]], None] = make_checker(EventUserGroupRemove)
check_user_group_remove_members: Callable[[str, dict[str, object]], None] = make_checker(EventUserGroupRemoveMembers)
check_user_group_remove_subgroups: Callable[[str, dict[str, object]], None] = make_checker(EventUserGroupRemoveSubgroups)
check_user_topic: Callable[[str, dict[str, object]], None] = make_checker(EventUserTopic)
check_web_reload_client_event: Callable[[str, dict[str, object]], None] = make_checker(EventWebReloadClient)


# Now for the slightly more tricky bits.  All the following functions
# get wrapped with more stringent checkers.  Some of the wrappers are
# reasonably sane functions that just check the data, not the shape of
# the data.
#
# But there are some ugly wrappers that work around the fact that
# a) our events are not very consistent and/or b) our types aren't
# robust.
#
# TODO: work through the bottom of this file to try to find ways to
#       simplify our types or make them more robust

_check_delete_message: Callable[[str, dict[str, object]], None] = make_checker(EventDeleteMessage)
_check_has_zoom_token: Callable[[str, dict[str, object]], None] = make_checker(EventHasZoomToken)
_check_presence: Callable[[str, dict[str, object]], None] = make_checker(EventPresence)
_check_realm_bot_add: Callable[[str, dict[str, object]], None] = make_checker(EventRealmBotAdd)
_check_realm_bot_update: Callable[[str, dict[str, object]], None] = make_checker(EventRealmBotUpdate)
_check_realm_default_update: Callable[[str, dict[str, object]], None] = make_checker(EventRealmUserSettingsDefaultsUpdate)
_check_realm_emoji_update: Callable[[str, dict[str, object]], None] = make_checker(EventRealmEmojiUpdate)
_check_realm_export: Callable[[str, dict[str, object]], None] = make_checker(EventRealmExport)
_check_realm_update: Callable[[str, dict[str, object]], None] = make_checker(EventRealmUpdate)
_check_realm_update_dict: Callable[[str, dict[str, object]], None] = make_checker(EventRealmUpdateDict)
_check_realm_user_update: Callable[[str, dict[str, object]], None] = make_checker(EventRealmUserUpdate)
_check_stream_update: Callable[[str, dict[str, object]], None] = make_checker(EventStreamUpdate)
_check_subscription_update: Callable[[str, dict[str, object]], None] = make_checker(EventSubscriptionUpdate)
_check_update_display_settings: Callable[[str, dict[str, object]], None] = make_checker(EventUpdateDisplaySettings)
_check_update_global_notifications: Callable[[str, dict[str, object]], None] = make_checker(EventUpdateGlobalNotifications)
_check_update_message: Callable[[str, dict[str, object]], None] = make_checker(EventUpdateMessage)
_check_user_group_update: Callable[[str, dict[str, object]], None] = make_checker(EventUserGroupUpdate)
_check_user_settings_update: Callable[[str, dict[str, object]], None] = make_checker(EventUserSettingsUpdate)
_check_user_status: Callable[[str, dict[str, object]], None] = make_checker(EventUserStatus)


PERSON_TYPES: dict[str, type[BaseModel]] = dict(
    avatar_fields=PersonAvatarFields,
    bot_owner_id=PersonBotOwnerId,
    custom_profile_field=PersonCustomProfileField,
    delivery_email=PersonDeliveryEmail,
    email=PersonEmail,
    full_name=PersonFullName,
    is_billing_admin=PersonIsBillingAdmin,
    role=PersonRole,
    timezone=PersonTimezone,
    is_active=PersonIsActive,
)


def check_delete_message(
    var_name: str,
    event: dict[str, object],
    message_type: Literal["stream", "private"],
    num_message_ids: int,
    is_legacy: bool,
) -> None:
    _check_delete_message(var_name, event)

    keys = {"id", "type", "message_type"}

    assert event["message_type"] == message_type

    if message_type == "stream":
        keys |= {"stream_id", "topic"}
    elif message_type == "private":
        pass
    else:
        raise AssertionError("unexpected message_type")

    if is_legacy:
        assert num_message_ids == 1
        keys.add("message_id")
    else:
        assert isinstance(event["message_ids"], list)
        assert num_message_ids == len(event["message_ids"])
        keys.add("message_ids")

    assert set(event.keys()) == keys


def check_has_zoom_token(
    var_name: str,
    event: dict[str, object],
    value: bool,
) -> None:
    _check_has_zoom_token(var_name, event)
    assert event["value"] == value


def check_presence(
    var_name: str,
    event: dict[str, object],
    has_email: bool,
    presence_key: str,
    status: str,
) -> None:
    _check_presence(var_name, event)

    assert ("email" in event) == has_email

    assert isinstance(event["presence"], dict)

    # Our tests only have one presence value.
    [(event_presence_key, event_presence_value)] = event["presence"].items()
    assert event_presence_key == presence_key
    assert event_presence_value["status"] == status


def check_realm_bot_add(
    var_name: str,
    event: dict[str, object],
) -> None:
    _check_realm_bot_add(var_name, event)

    assert isinstance(event["bot"], dict)
    bot_type = event["bot"]["bot_type"]

    services = event["bot"]["services"]

    if bot_type == UserProfile.DEFAULT_BOT:
        assert services == []
    elif bot_type == UserProfile.OUTGOING_WEBHOOK_BOT:
        assert len(services) == 1
        validate_with_model(services[0], BotServicesOutgoing)
    elif bot_type == UserProfile.EMBEDDED_BOT:
        assert len(services) == 1
        validate_with_model(services[0], BotServicesEmbedded)
    else:
        raise AssertionError(f"Unknown bot_type: {bot_type}")


def check_realm_bot_update(
    var_name: str,
    event: dict[str, object],
    field: str,
) -> None:
    _check_realm_bot_update(var_name, event)

    assert isinstance(event["bot