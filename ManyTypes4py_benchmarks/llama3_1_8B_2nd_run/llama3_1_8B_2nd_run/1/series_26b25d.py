from typing import Any, Callable, Dict, List, Optional, Union

class Series(base.IndexOpsMixin, NDFrame):
    ...

    def __init__(self, data: Any, index: Any, dtype: Any, name: Optional[str], copy: bool) -> None:
        ...

    def _init_dict(self, data: Dict, index: Any, dtype: Any) -> Tuple[BlockManager, Index]:
        ...

    def __arrow_c_stream__(self, requested_schema: Optional[PyCapsule]) -> PyCapsule:
        ...

    @property
    def _constructor(self) -> Callable[..., 'Series']:
        ...

    def _constructor_from_mgr(self, mgr: BlockManager, axes: Any) -> 'Series':
        ...

    @property
    def _constructor_expanddim(self) -> Callable[..., 'DataFrame']:
        ...

    def _constructor_expanddim_from_mgr(self, mgr: BlockManager, axes: Any) -> 'DataFrame':
        ...

    @property
    def _can_hold_na(self) -> bool:
        ...

    @property
    def dtype(self) -> np.dtype:
        ...

    @property
    def dtypes(self) -> np.dtype:
        ...

    @property
    def name(self) -> Optional[str]:
        ...

    @name.setter
    def name(self, value: str) -> None:
        ...

    @property
    def values(self) -> np.ndarray:
        ...

    @property
    def _values(self) -> np.ndarray:
        ...

    @property
    def _references(self) -> List[Union[int, int]]:
        ...

    def __array__(self, dtype: Optional[np.dtype], copy: bool) -> np.ndarray:
        ...

    def __getitem__(self, key: Any) -> Any:
        ...

    def __setitem__(self, key: Any, value: Any) -> None:
        ...

    def repeat(self, repeats: Union[int, np.ndarray], axis: Optional[int]) -> 'Series':
        ...

    def reset_index(self, level: Optional[Union[int, str]], drop: bool, name: Optional[str], inplace: bool, allow_duplicates: bool) -> Union['Series', None]:
        ...

    def to_string(self, buf: Optional[IO], na_rep: str, float_format: Optional[str], header: bool, index: bool, length: bool, dtype: bool, name: bool, max_rows: Optional[int], min_rows: Optional[int]) -> Union[str, None]:
        ...

    def to_markdown(self, buf: Optional[Union[str, Path, IO]], mode: str, index: bool, storage_options: Optional[Dict[str, Any]], **kwargs: Any) -> Union[str, None]:
        ...

    def items(self) -> Iterator[Tuple[Union[str, int], Any]]:
        ...

    def keys(self) -> Index:
        ...

    def to_dict(self, into: Optional[Dict]) -> Dict:
        ...

    def to_frame(self, name: Optional[str]) -> 'DataFrame':
        ...

    def _set_name(self, name: str, inplace: bool, deep: Optional[bool]) -> 'Series':
        ...

    def groupby(self, by: Any, level: Optional[Union[int, str]], as_index: bool, sort: bool, group_keys: bool, observed: bool, dropna: bool) -> SeriesGroupBy:
        ...

    def count(self) -> int:
        ...

    def mode(self, dropna: bool) -> 'Series':
        ...

    def unique(self) -> np.ndarray:
        ...

    def drop_duplicates(self, keep: str, inplace: bool, ignore_index: bool) -> Union['Series', None]:
        ...

    def duplicated(self, keep: str) -> 'Series':
        ...

    def idxmin(self, axis: int, skipna: bool) -> Index:
        ...

    def idxmax(self, axis: int, skipna: bool) -> Index:
        ...

    def round(self, decimals: int, **kwargs: Any) -> 'Series':
        ...

    def quantile(self, q: float, interpolation: str) -> Union[float, 'Series']:
        ...

    def corr(self, other: 'Series', method: str, min_periods: Optional[int]) -> float:
        ...

    def cov(self, other: 'Series', min_periods: Optional[int], ddof: int) -> float:
        ...

    def diff(self, periods: int) -> 'Series':
        ...

    def autocorr(self, lag: int) -> float:
        ...

    def dot(self, other: Union['Series', 'DataFrame', np.ndarray]) -> Union['Series', np.ndarray]:
        ...

    def __matmul__(self, other: Any) -> Union['Series', np.ndarray]:
        ...

    def __rmatmul__(self, other: Any) -> Union['Series', np.ndarray]:
        ...

    def searchsorted(self, value: Any, side: str, sorter: Optional[np.ndarray]) -> np.ndarray:
        ...

    def _append(self, to_append: Any, ignore_index: bool, verify_integrity: bool) -> 'DataFrame':
        ...

    def compare(self, other: 'Series', align_axis: int, keep_shape: bool, keep_equal: bool, result_names: Tuple[str, str]) -> Union['DataFrame', None]:
        ...

    def combine(self, other: Any, func: Callable, fill_value: Optional[Any]) -> 'Series':
        ...

    def combine_first(self, other: 'Series') -> 'Series':
        ...

    def update(self, other: Any) -> None:
        ...

    def sort_values(self, axis: int, ascending: bool, inplace: bool, kind: str, na_position: str, ignore_index: bool, key: Optional[Callable]) -> Union['Series', None]:
        ...

    def sort_index(self, axis: int, level: Optional[Union[int, str]], ascending: bool, inplace: bool, kind: str, na_position: str, sort_remaining: bool, ignore_index: bool, key: Optional[Callable]) -> Union['Series', None]:
        ...

    def argsort(self, axis: int, kind: str, order: Optional[str], stable: Optional[bool]) -> np.ndarray:
        ...

    def nlargest(self, n: int, keep: str) -> 'Series':
        ...

    def nsmallest(self, n: int, keep: str) -> 'Series':
        ...

    def swaplevel(self, i: int, j: int, copy: bool) -> 'Series':
        ...

    def reorder_levels(self, order: List[Union[int, str]]) -> 'Series':
        ...

    def explode(self, ignore_index: bool) -> 'Series':
        ...

    def unstack(self, level: int, fill_value: Optional[Any], sort: bool) -> 'DataFrame':
        ...

    def map(self, arg: Union[Callable, Mapping, 'Series'], na_action: Optional[str]) -> 'Series':
        ...

    def _gotitem(self, key: Any, ndim: int, subset: Optional[Any]) -> 'Series':
        ...

    def aggregate(self, func: Optional[Dict[str, Callable]], axis: int, *args: Any, **kwargs: Any) -> 'Series':
        ...

    def transform(self, func: Callable, axis: int, *args: Any, **kwargs: Any) -> 'Series':
        ...

    def apply(self, func: Callable, args: Tuple[Any, ...], by_row: str, **kwargs: Any) -> Union['Series', 'DataFrame']:
        ...

    def rename(self, index: Optional[Any], axis: Optional[int], copy: bool, inplace: bool, level: Optional[Union[int, str]], errors: str) -> Union['Series', None]:
        ...

    def rename_axis(self, mapper: Any, axis: int, inplace: bool, copy: bool) -> Union['Series', None]:
        ...

    def drop(self, labels: Any, axis: int, index: Optional[Any], columns: Optional[Any], level: Optional[Union[int, str]], inplace: bool, errors: str) -> Union['Series', None]:
        ...

    def pop(self, item: Any) -> Any:
        ...

    def info(self, verbose: Optional[bool], buf: Optional[IO], max_cols: Optional[int], memory_usage: Optional[bool], show_counts: bool) -> None:
        ...

    def memory_usage(self, index: bool, deep: bool) -> int:
        ...

    def isin(self, values: Union[Set, List]) -> 'Series':
        ...

    def between(self, left: Any, right: Any, inclusive: str) -> 'Series':
        ...

    def case_when(self, caselist: List[Tuple[Callable, Callable]]) -> 'Series':
        ...

    def isna(self) -> 'Series':
        ...

    def isnull(self) -> 'Series':
        ...

    def notna(self) -> 'Series':
        ...

    def notnull(self) -> 'Series':
        ...

    def dropna(self, axis: int, inplace: bool, how: Optional[str], ignore_index: bool) -> Union['Series', None]:
        ...

    def to_timestamp(self, freq: Optional[str], how: str, copy: bool) -> 'Series':
        ...

    def to_period(self, freq: Optional[str], copy: bool) -> 'Series':
        ...

    def _reduce(self, op: Callable, name: str, axis: int, skipna: bool, numeric_only: bool, filter_type: Optional[str], **kwargs: Any) -> Any:
        ...

    def any(self, axis: int, bool_only: bool, skipna: bool, **kwargs: Any) -> Any:
        ...

    def all(self, axis: int, bool_only: bool, skipna: bool, **kwargs: Any) -> Any:
        ...

    def min(self, axis: int, skipna: bool, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def max(self, axis: int, skipna: bool, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def sum(self, axis: int, skipna: bool, numeric_only: bool, min_count: int, **kwargs: Any) -> Any:
        ...

    def prod(self, axis: int, skipna: bool, numeric_only: bool, min_count: int, **kwargs: Any) -> Any:
        ...

    def mean(self, axis: int, skipna: bool, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def median(self, axis: int, skipna: bool, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def sem(self, axis: int, skipna: bool, ddof: int, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def var(self, axis: int, skipna: bool, ddof: int, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def std(self, axis: int, skipna: bool, ddof: int, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def skew(self, axis: int, skipna: bool, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def kurt(self, axis: int, skipna: bool, numeric_only: bool, **kwargs: Any) -> Any:
        ...

    def cummin(self, axis: int, skipna: bool, **kwargs: Any) -> Any:
        ...

    def cummax(self, axis: int, skipna: bool, **kwargs: Any) -> Any:
        ...

    def cumsum(self, axis: int, skipna: bool, **kwargs: Any) -> Any:
        ...

    def cumprod(self, axis: int, skipna: bool, **kwargs: Any) -> Any:
        ...
