from typing import Any, Generic, Iterable, List, Optional, TypeVar, Union, cast

T = TypeVar('T')

class Series(Generic[T], IndexOpsMixin):
    # ...

    @property
    def spark(self) -> 'SparkSeriesMethods':
        # ...

    @property
    def dtypes(self) -> 'SeriesType':
        # ...

    @property
    def axes(self) -> List['Index']:
        # ...

    @property
    def spark_type(self) -> 'DataType':
        # ...

    def add(self, other: 'Series') -> 'Series':
        # ...

    def radd(self, other: 'Series') -> 'Series':
        # ...

    def div(self, other: 'Series') -> 'Series':
        # ...

    def rdiv(self, other: 'Series') -> 'Series':
        # ...

    def truediv(self, other: 'Series') -> 'Series':
        # ...

    def rtruediv(self, other: 'Series') -> 'Series':
        # ...

    def mul(self, other: 'Series') -> 'Series':
        # ...

    def rmul(self, other: 'Series') -> 'Series':
        # ...

    def sub(self, other: 'Series') -> 'Series':
        # ...

    def rsub(self, other: 'Series') -> 'Series':
        # ...

    def mod(self, other: 'Series') -> 'Series':
        # ...

    def rmod(self, other: 'Series') -> 'Series':
        # ...

    def pow(self, other: 'Series') -> 'Series':
        # ...

    def rpow(self, other: 'Series') -> 'Series':
        # ...

    def floordiv(self, other: 'Series') -> 'Series':
        # ...

    def rfloordiv(self, other: 'Series') -> 'Series':
        # ...

    def eq(self, other: 'Series') -> 'Series':
        # ...

    def gt(self, other: 'Series') -> 'Series':
        # ...

    def ge(self, other: 'Series') -> 'Series':
        # ...

    def lt(self, other: 'Series') -> 'Series':
        # ...

    def le(self, other: 'Series') -> 'Series':
        # ...

    def ne(self, other: 'Series') -> 'Series':
        # ...

    def divmod(self, other: 'Series') -> 'Tuple[Series, Series]':
        # ...

    def rdivmod(self, other: 'Series') -> 'Tuple[Series, Series]':
        # ...

    def between(self, left: Any, right: Any, inclusive: bool = True) -> 'Series':
        # ...

    def map(self, arg: Union[dict, 'Callable']) -> 'Series':
        # ...

    def alias(self, name: str) -> 'Series':
        # ...

    @property
    def shape(self) -> 'Tuple[int, int]':
        # ...

    @property
    def name(self) -> Optional[str]:
        # ...

    @name.setter
    def name(self, name: str) -> None:
        # ...

    def rename(self, index: Optional[Union[str, List[str]]] = None, **kwargs) -> 'Series':
        # ...

    def rename_axis(self, mapper: Optional[Union[str, List[str], 'Callable']] = None, index: Optional[Union[str, List[str], 'Callable']] = None, inplace: bool = False) -> 'Series':
        # ...

    @property
    def index(self) -> 'Index':
        # ...

    @property
    def is_unique(self) -> bool:
        # ...

    def reset_index(self, level: Optional[Union[int, str, List[Union[int, str]]]] = None, drop: bool = False, name: Optional[str] = None, inplace: bool = False) -> Union['Series', 'DataFrame']:
        # ...

    def to_frame(self, name: Optional[str] = None) -> 'DataFrame':
        # ...

    def to_string(self, buf: Optional['IO[Any]] = None, na_rep: str = 'NaN', float_format: Optional[Callable[[float], str]] = None, header: bool = True, index: bool = True, length: bool = False, dtype: bool = False, name: bool = False, max_rows: Optional[int] = None) -> str:
        # ...

    def to_clipboard(self, excel: bool = True, sep: Optional[str] = None, **kwargs) -> None:
        # ...

    def to_dict(self, into: type = dict) -> 'Mapping[Any, Any]':
        # ...

    def to_latex(self, buf: Optional['IO[Any]] = None, columns: Optional[List[str]] = None, col_space: Optional[Dict[str, str]] = None, header: bool = True, index: bool = True, na_rep: str = 'NaN', formatters: Optional[List[Callable[[Any], str]]] = None, float_format: Optional[Callable[[float], str]] = None, sparsify: Optional[Callable[[Any], str]] = None, index_names: bool = True, bold_rows: bool = False, column_format: Optional[str] = None, longtable: bool = False, escape: bool = True, encoding: Optional[str] = None, decimal: str = '.', multicolumn: bool = False, multicolumn_format: Optional[str] = None, multirow: bool = False) -> str:
        # ...

    def to_pandas(self) -> 'Series':
        # ...

    def to_list(self) -> List[T]:
        # ...

    def drop_duplicates(self, keep: Optional[str] = 'first', inplace: bool = False) -> Union['Series', None]:
        # ...

    def reindex(self, index: Optional['Index'] = None, fill_value: Any = None) -> 'Series':
        # ...

    def reindex_like(self, other: Union['Series', 'DataFrame']) -> 'Series':
        # ...

    def fillna(self, value: Any = None, method: Optional[str] = None, axis: int = 0, inplace: bool = False, limit: Optional[int] = None) -> Union['Series', None]:
        # ...

    def dropna(self, axis: int = 0, inplace: bool = False, **kwargs) -> Union['Series', None]:
        # ...

    def clip(self, lower: Optional[float] = None, upper: Optional[float] = None) -> 'Series':
        # ...

    def drop(self, labels: Optional[Union[str, List[str]]] = None, index: Optional[Union[str, List[str]]] = None, level: Optional[Union[int, str]] = None) -> 'Series':
        # ...

    def head(self, n: int = 5) -> 'Series':
        # ...

    def last(self, offset: Union[str, 'DateOffset']) -> 'Series':
        # ...

    def first(self, offset: Union[str, 'DateOffset']) -> 'Series':
        # ...

    def unique(self) -> 'Series':
        # ...

    def sort_values(self, ascending: bool = True, inplace: bool = False, na_position: str = 'last') -> Union['Series', None]:
        # ...

    def sort_index(self, axis: int = 0, level: Optional[Union[int, str]] = None, ascending: bool = True, inplace: bool = False, kind: Optional[str] = None, na_position: str = 'last') -> Union['Series', None]:
        # ...

    def swaplevel(self, i: int = -2, j: int = -1, copy: bool = True) -> 'Series':
        # ...

    def swapaxes(self, i: int = 0, j: int = 1, copy: bool = True) -> 'Series':
        # ...

    def add_prefix(self, prefix: str) -> 'Series':
        # ...

    def add_suffix(self, suffix: str) -> 'Series':
        # ...

    def corr(self, other: 'Series', method: str = 'pearson') -> float:
        # ...

    def nsmallest(self, n: int = 5) -> 'Series':
        # ...

    def nlargest(self, n: int = 5) -> 'Series':
        # ...

    def append(self, to_append: Union['Series', 'DataFrame'], ignore_index: bool = False, verify_integrity: bool = False) -> 'Series':
        # ...

    def sample(self, n: Optional[int] = None, frac: Optional[float] = None, replace: bool = False, random_state: Optional[int] = None) -> 'Series':
        # ...

    def hist(self, bins: int = 10, **kwargs) -> None:
        # ...

    def apply(self, func: Callable[[T], Any], args: Tuple[Any, ...] = (), **kwargs) -> 'Series':
        # ...

    def aggregate(self, func: Union[str, List[str]]) -> Union[Any, 'Series']:
        # ...

    def transpose(self) -> 'Series':
        # ...

    def transform(self, func: Callable[[T], Any], axis: int = 0, *args: Any, **kwargs: Any) -> 'Series':
        # ...

    def transform_batch(self, func: Callable[[T], Any], *args: Any, **kwargs: Any) -> 'Series':
        # ...

    def round(self, decimals: int = 0) -> 'Series':
        # ...

    def quantile(self, q: Union[float, List[float]], accuracy: int = 10000) -> Union[Any, 'Series']:
        # ...

    def rank(self, method: str = 'average', ascending: bool = True) -> 'Series':
        # ...

    def diff(self, periods: int = 1) -> 'Series':
        # ...

    def idxmax(self, skipna: bool = True) -> Any:
        # ...

    def idxmin(self, skipna: bool = True) -> Any:
        # ...

    def pop(self, item: Union[str, Tuple[str, ...]]) -> T:
        # ...

    def copy(self, deep: Optional[bool] = None) -> 'Series':
        # ...

    def mode(self, dropna: bool = True) -> 'Series':
        # ...

    def keys(self) -> 'Index':
        # ...

    def replace(self, to_replace: Any, value: Any = None, regex: bool = False) -> 'Series':
        # ...

    def update(self, other: 'Series') -> None:
        # ...

    def where(self, cond: 'Series', other: Any = np.nan) -> 'Series':
        # ...

    def mask(self, cond: 'Series', other: Any = np.nan) -> 'Series':
        # ...

    def xs(self, key: Union[str, Tuple[str, ...]], level: Optional[Union[int, str]] = None) -> 'Series':
        # ...

    def pct_change(self, periods: int = 1) -> 'Series':
        # ...

    def combine_first(self, other: 'Series') -> 'Series':
        # ...

    def dot(self, other: Union['Series', 'DataFrame']) -> Union[Any, 'Series']:
        # ...

    def __matmul__(self, other: Union['Series', 'DataFrame']) -> Union[Any, 'Series']:
        # ...

    def repeat(self, repeats: Union[int, 'Series']) -> 'Series':
        # ...

    def asof(self, where: Any) -> Union[Any, 'Series']:
        # ...

    def mad(self) -> float:
        # ...

    def unstack(self, level: int = -1) -> 'DataFrame':
        # ...

    def item(self) -> T:
        # ...

    def iteritems(self) -> Iterable[Tuple[Any, T]]:
        # ...

    def items(self) -> Iterable[Tuple[Any, T]]:
        # ...

    def droplevel(self, level: Union[int, str, List[Union[int, str]]]) -> 'Series':
        # ...

    def tail(self, n: int = 5) -> 'Series':
        # ...

    def explode(self) -> 'Series':
        # ...

    def argsort(self) -> 'Series':
        # ...

    def argmax(self) -> int:
        # ...

    def argmin(self) -> int:
        # ...

    def compare(self, other: 'Series', keep_shape: bool = False, keep_equal: bool = False) -> 'DataFrame':
        # ...

    def align(self, other: Union['Series', 'DataFrame'], join: str = 'outer', axis: int = 0, copy: bool = True) -> Tuple['Series', Any]:
        # ...

    def between_time(self, start_time: Union['datetime.time', str], end_time: Union['datetime.time', str], include_start: bool = True, include_end: bool = True, axis: int = 0) -> 'Series':
        # ...

    def at_time(self, time: Union['datetime.time', str], asof: bool = False, axis: int = 0) -> 'Series':
        # ...

    def _cum(self, func: Callable[[T], T], skipna: bool = True, part_cols: Tuple[str, ...] = (), ascending: bool = True) -> 'Series':
        # ...

    def _cumsum(self, skipna: bool = True, part_cols: Tuple[str, ...] = ()) -> 'Series':
        # ...

    def _cumprod(self, skipna: bool = True, part_cols: Tuple[str, ...] = ()) -> 'Series':
        # ...

    def _apply_series_op(self, op: Callable[['Series'], 'Series'], should_resolve: bool = False) -> 'Series':
        # ...

    def _reduce_for_stat_function(self, sfun: Callable[[T, 'DataType'], T], name: str, axis: int = 0, numeric_only: bool = False, **kwargs: Any) -> Any:
        # ...

    def __getitem__(self, key: Any) -> 'Series':
        # ...

    def __getattr__(self, item: str) -> Any:
        # ...
