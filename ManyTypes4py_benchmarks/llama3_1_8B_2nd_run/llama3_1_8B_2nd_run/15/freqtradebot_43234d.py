from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime, time, timedelta, timezone

class FreqtradeBot(LoggingMixin):
    # ...

    def __init__(self, config: Dict[str, Any]) -> None:
        # ...

    def notify_status(self, msg: str, msg_type: RPCMessageType = RPCMessageType.STATUS) -> None:
        # ...

    def cleanup(self) -> None:
        # ...

    def startup(self) -> None:
        # ...

    def process(self) -> bool:
        # ...

    def process_stopped(self) -> None:
        # ...

    def check_for_open_trades(self) -> None:
        # ...

    def _refresh_active_whitelist(self, trades: Optional[List[Trade]] = None) -> List[str]:
        # ...

    def get_free_open_trades(self) -> int:
        # ...

    def update_all_liquidation_prices(self) -> None:
        # ...

    def update_funding_fees(self) -> None:
        # ...

    def startup_backpopulate_precision(self) -> None:
        # ...

    def startup_update_open_orders(self) -> None:
        # ...

    def update_trades_without_assigned_fees(self) -> None:
        # ...

    def handle_insufficient_funds(self, trade: Trade) -> None:
        # ...

    def handle_onexchange_order(self, trade: Trade) -> bool:
        # ...

    def enter_positions(self) -> int:
        # ...

    def create_trade(self, pair: str) -> bool:
        # ...

    def process_open_trade_positions(self) -> None:
        # ...

    def check_and_call_adjust_trade_position(self, trade: Trade) -> None:
        # ...

    def _check_depth_of_market(self, pair: str, conf: Dict[str, Any], side: SignalDirection) -> bool:
        # ...

    def execute_entry(self, pair: str, stake_amount: float, price: Optional[float] = None, *, is_short: bool = False, ordertype: Optional[str] = None, enter_tag: Optional[str] = None, trade: Optional[Trade] = None, mode: str = 'initial', leverage_: Optional[float] = None) -> bool:
        # ...

    def cancel_stoploss_on_exchange(self, trade: Trade) -> Trade:
        # ...

    def get_valid_enter_price_and_stake(self, pair: str, price: Optional[float], stake_amount: float, trade_side: str, entry_tag: Optional[str], trade: Optional[Trade], mode: str, leverage_: Optional[float]) -> Tuple[float, float, float]:
        # ...

    def _notify_enter(self, trade: Trade, order: Order, order_type: Optional[str], fill: bool = False, sub_trade: bool = False) -> None:
        # ...

    def _notify_enter_cancel(self, trade: Trade, order_type: str, reason: str, sub_trade: bool = False) -> None:
        # ...

    def exit_positions(self, trades: List[Trade]) -> int:
        # ...

    def handle_trade(self, trade: Trade) -> bool:
        # ...

    def _check_and_execute_exit(self, trade: Trade, exit_rate: float, enter: bool, exit_: bool, exit_tag: Optional[str]) -> bool:
        # ...

    def create_stoploss_order(self, trade: Trade, stop_price: float) -> bool:
        # ...

    def handle_stoploss_on_exchange(self, trade: Trade) -> bool:
        # ...

    def handle_trailing_stoploss_on_exchange(self, trade: Trade, order: Order) -> None:
        # ...

    def manage_trade_stoploss_orders(self, trade: Trade, stoploss_orders: List[Order]) -> None:
        # ...

    def manage_open_orders(self) -> None:
        # ...

    def handle_cancel_order(self, order: Order, order_obj: Order, trade: Trade, reason: str) -> None:
        # ...

    def emergency_exit(self, trade: Trade, price: float, sub_trade_amt: Optional[float] = None) -> None:
        # ...

    def replace_order_failed(self, trade: Trade, msg: str) -> None:
        # ...

    def replace_order(self, order: Order, order_obj: Order, trade: Trade) -> None:
        # ...

    def cancel_open_orders_of_trade(self, trade: Trade, sides: List[str], reason: str, replacing: bool = False) -> None:
        # ...

    def cancel_all_open_orders(self) -> None:
        # ...

    def handle_similar_open_order(self, trade: Trade, price: float, amount: float, side: str) -> bool:
        # ...

    def handle_cancel_enter(self, trade: Trade, order: Order, order_obj: Order, reason: str, replacing: bool = False) -> bool:
        # ...

    def handle_cancel_exit(self, trade: Trade, order: Order, order_obj: Order, reason: str) -> bool:
        # ...

    def _safe_exit_amount(self, trade: Trade, pair: str, amount: float) -> float:
        # ...

    def execute_trade_exit(self, trade: Trade, limit: float, exit_check: ExitCheckTuple, *, exit_tag: Optional[str] = None, ordertype: Optional[str] = None, sub_trade_amt: Optional[float] = None) -> bool:
        # ...

    def _notify_exit(self, trade: Trade, order_type: Optional[str], fill: bool = False, sub_trade: bool = False, order: Optional[Order] = None) -> None:
        # ...

    def _notify_exit_cancel(self, trade: Trade, order_type: str, reason: str, order_id: str, sub_trade: bool = False) -> None:
        # ...

    def order_obj_or_raise(self, order_id: str, order_obj: Order) -> Order:
        # ...

    def update_trade_state(self, trade: Trade, order_id: str, action_order: Optional[Order] = None, *, stoploss_order: bool = False, send_msg: bool = True) -> bool:
        # ...

    def _update_trade_after_fill(self, trade: Trade, order: Order, send_msg: bool) -> Trade:
        # ...

    def order_close_notify(self, trade: Trade, order: Order, stoploss_order: bool, send_msg: bool) -> None:
        # ...

    def handle_protections(self, pair: str, side: str) -> None:
        # ...

    def apply_fee_conditional(self, trade: Trade, trade_base_currency: str, amount: float, fee_abs: float, order_obj: Order) -> Optional[float]:
        # ...

    def handle_order_fee(self, trade: Trade, order_obj: Order, order: Order) -> None:
        # ...

    def get_real_amount(self, trade: Trade, order: Order, order_obj: Order) -> Optional[float]:
        # ...

    def _trades_valid_for_fee(self, trades: List[Dict[str, Any]]) -> bool:
        # ...

    def fee_detection_from_trades(self, trade: Trade, order: Order, order_obj: Order, order_amount: float, trades: List[Dict[str, Any]]) -> Optional[float]:
        # ...

    def get_valid_price(self, custom_price: Optional[float], proposed_price: float) -> float:
        # ...
