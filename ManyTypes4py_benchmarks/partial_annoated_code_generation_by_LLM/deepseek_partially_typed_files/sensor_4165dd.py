"""Sensor for Shelly."""
from __future__ import annotations
from collections.abc import Callable
from dataclasses import dataclass
from typing import Final, cast, Any
from aioshelly.block_device import Block
from aioshelly.const import RPC_GENERATIONS
from homeassistant.components.sensor import DOMAIN as SENSOR_PLATFORM, RestoreSensor, SensorDeviceClass, SensorEntity, SensorEntityDescription, SensorExtraStoredData, SensorStateClass
from homeassistant.const import CONCENTRATION_PARTS_PER_MILLION, DEGREE, LIGHT_LUX, PERCENTAGE, SIGNAL_STRENGTH_DECIBELS_MILLIWATT, EntityCategory, UnitOfApparentPower, UnitOfElectricCurrent, UnitOfElectricPotential, UnitOfEnergy, UnitOfFrequency, UnitOfPower, UnitOfTemperature
from homeassistant.core import HomeAssistant
from homeassistant.helpers.device_registry import CONNECTION_BLUETOOTH, DeviceInfo
from homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback
from homeassistant.helpers.entity_registry import RegistryEntry
from homeassistant.helpers.typing import StateType
from .const import CONF_SLEEP_PERIOD, ROLE_TO_DEVICE_CLASS_MAP, SHAIR_MAX_WORK_HOURS
from .coordinator import ShellyBlockCoordinator, ShellyConfigEntry, ShellyRpcCoordinator
from .entity import BlockEntityDescription, RestEntityDescription, RpcEntityDescription, ShellyBlockAttributeEntity, ShellyRestAttributeEntity, ShellyRpcAttributeEntity, ShellySleepingBlockAttributeEntity, ShellySleepingRpcAttributeEntity, async_setup_entry_attribute_entities, async_setup_entry_rest, async_setup_entry_rpc
from .utils import async_remove_orphaned_entities, get_device_entry_gen, get_device_uptime, get_virtual_component_ids, is_rpc_wifi_stations_disabled

@dataclass(frozen=True, kw_only=True)
class BlockSensorDescription(BlockEntityDescription, SensorEntityDescription):
    """Class to describe a BLOCK sensor."""

@dataclass(frozen=True, kw_only=True)
class RpcSensorDescription(RpcEntityDescription, SensorEntityDescription):
    """Class to describe a RPC sensor."""
    device_class_fn: Callable[[dict[str, Any]], SensorDeviceClass | None] | None = None

@dataclass(frozen=True, kw_only=True)
class RestSensorDescription(RestEntityDescription, SensorEntityDescription):
    """Class to describe a REST sensor."""

class RpcSensor(ShellyRpcAttributeEntity, SensorEntity):
    """Represent a RPC sensor."""
    entity_description: RpcSensorDescription

    def __init__(self, coordinator: ShellyRpcCoordinator, key: str, attribute: str, description: RpcSensorDescription) -> None:
        """Initialize select."""
        super().__init__(coordinator, key, attribute, description)
        if self.option_map:
            self._attr_options = list(self.option_map.values())
        if description.device_class_fn is not None:
            if (device_class := description.device_class_fn(coordinator.device.config[key])):
                self._attr_device_class = device_class

    @property
    def native_value(self) -> StateType:
        """Return value of sensor."""
        attribute_value = self.attribute_value
        if not self.option_map:
            return attribute_value
        if not isinstance(attribute_value, str):
            return None
        return self.option_map[attribute_value]

class RpcBluTrvSensor(RpcSensor):
    """Represent a RPC BluTrv sensor."""

    def __init__(self, coordinator: ShellyRpcCoordinator, key: str, attribute: str, description: RpcSensorDescription) -> None:
        """Initialize."""
        super().__init__(coordinator, key, attribute, description)
        ble_addr: str = coordinator.device.config[key]['addr']
        self._attr_device_info = DeviceInfo(connections={(CONNECTION_BLUETOOTH, ble_addr)})

SENSORS: dict[tuple[str, str], BlockSensorDescription] = {('device', 'battery'): BlockSensorDescription(key='device|battery', name='Battery', native_unit_of_measurement=PERCENTAGE, device_class=SensorDeviceClass.BATTERY, state_class=SensorStateClass.MEASUREMENT, removal_condition=lambda settings, _: settings.get('external_power') == 1, available=lambda block: cast(int, block.battery) != -1, entity_category=EntityCategory.DIAGNOSTIC), ('device', 'deviceTemp'): BlockSensorDescription(key='device|deviceTemp', name='Device temperature', native_unit_of_measurement=UnitOfTemperature.CELSIUS, suggested_display_precision=1, device_class=SensorDeviceClass.TEMPERATURE, state_class=SensorStateClass.MEASUREMENT, entity_registry_enabled_default=False, entity_category=EntityCategory.DIAGNOSTIC), ('emeter', 'current'): BlockSensorDescription(key='emeter|current', name='Current', native_unit_of_measurement=UnitOfElectricCurrent.AMPERE, device_class=SensorDeviceClass.CURRENT, state_class=SensorStateClass.MEASUREMENT), ('device', 'neutralCurrent'): BlockSensorDescription(key='device|neutralCurrent', name='Neutral current', native_unit_of_measurement=UnitOfElectricCurrent.AMPERE, device_class=SensorDeviceClass.CURRENT, state_class=SensorStateClass.MEASUREMENT, entity_registry_enabled_default=False), ('light', 'power'): BlockSensorDescription(key='light|power', name='Power', native_unit_of_measurement=UnitOfPower.WATT, suggested_display_precision=1, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT, entity_registry_enabled_default=False), ('device', 'power'): BlockSensorDescription(key='device|power', name='Power', native_unit_of_measurement=UnitOfPower.WATT, suggested_display_precision=1, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), ('emeter', 'power'): BlockSensorDescription(key='emeter|power', name='Power', native_unit_of_measurement=UnitOfPower.WATT, suggested_display_precision=1, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), ('device', 'voltage'): BlockSensorDescription(key='device|voltage', name='Voltage', native_unit_of_measurement=UnitOfElectricPotential.VOLT, suggested_display_precision=1, device_class=SensorDeviceClass.VOLTAGE, state_class=SensorStateClass.MEASUREMENT, entity_registry_enabled_default=False), ('emeter', 'voltage'): BlockSensorDescription(key='emeter|voltage', name='Voltage', native_unit_of_measurement=UnitOfElectricPotential.VOLT, suggested_display_precision=1, device_class=SensorDeviceClass.VOLTAGE, state_class=SensorStateClass.MEASUREMENT), ('emeter', 'powerFactor'): BlockSensorDescription(key='emeter|powerFactor', name='Power factor', suggested_display_precision=2, device_class=SensorDeviceClass.POWER_FACTOR, state_class=SensorStateClass.MEASUREMENT), ('relay', 'power'): BlockSensorDescription(key='relay|power', name='Power', native_unit_of_measurement=UnitOfPower.WATT, suggested_display_precision=1, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), ('roller', 'rollerPower'): BlockSensorDescription(key='roller|rollerPower', name='Power', native_unit_of_measurement=UnitOfPower.WATT, suggested_display_precision=1, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), ('device', 'energy'): BlockSensorDescription(key='device|energy', name='Energy', native_unit_of_measurement=UnitOfEnergy.WATT_HOUR, suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR, value=lambda value: value / 60, suggested_display_precision=2, device_class=SensorDeviceClass.ENERGY, state_class=SensorStateClass.TOTAL_INCREASING), ('emeter', 'energy'): BlockSensorDescription(key='emeter|energy', name='Energy', native_unit_of_measurement=UnitOfEnergy.WATT_HOUR, suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR, suggested_display_precision=2, device_class=SensorDeviceClass.ENERGY, state_class=SensorStateClass.TOTAL_INCREASING, available=lambda block: cast(int, block.energy) != -1), ('emeter', 'energyReturned'): BlockSensorDescription(key='emeter|energyReturned', name='Energy returned', native_unit_of_measurement=UnitOfEnergy.WATT_HOUR, suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR, suggested_display_precision=2, device_class=SensorDeviceClass.ENERGY, state_class=SensorStateClass.TOTAL_INCREASING, available=lambda block: cast(int, block.energyReturned) != -1), ('light', 'energy'): BlockSensorDescription(key='light|energy', name='Energy', native_unit_of_measurement=UnitOfEnergy.WATT_HOUR, suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR, value=lambda value: value / 60, suggested_display_precision=2, device_class=SensorDeviceClass.ENERGY, state_class=SensorStateClass.TOTAL_INCREASING, entity_registry_enabled_default=False), ('relay', 'energy'): BlockSensorDescription(key='relay|energy', name='Energy', native_unit_of_measurement=UnitOfEnergy.WATT_HOUR, suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR, value=lambda value: value / 60, suggested_display_precision=2, device_class=SensorDeviceClass.ENERGY, state_class=SensorStateClass.TOTAL_INCREASING), ('roller', 'rollerEnergy'): BlockSensorDescription(key='roller|rollerEnergy', name='Energy', native_unit_of_measurement=UnitOfEnergy.WATT_HOUR, suggested_unit_of_measurement=UnitOfEnergy.KILO_WATT_HOUR, value=lambda value: value / 60, suggested_display_precision=2, device_class=SensorDeviceClass.ENERGY, state_class=SensorStateClass.TOTAL_INCREASING), ('sensor', 'concentration'): BlockSensorDescription(key='sensor|concentration', name='Gas concentration', native_unit_of_measurement=CONCENTRATION_PARTS_PER_MILLION, translation_key='gas_concentration', state_class=SensorStateClass.MEASUREMENT), ('sensor', 'temp'): BlockSensorDescription(key='sensor|temp', name='Temperature', native_unit_of_measurement=UnitOfTemperature.CELSIUS, suggested_display_precision=1, device_class=SensorDeviceClass.TEMPERATURE, state_class=SensorStateClass.MEASUREMENT, entity_category=EntityCategory.DIAGNOSTIC), ('sensor', 'extTemp'): BlockSensorDescription(key='sensor|extTemp', name='Temperature', native_unit_of_measurement=UnitOfTemperature.CELSIUS, suggested_display_precision=1, device_class=SensorDeviceClass.TEMPERATURE, state_class=SensorStateClass.MEASUREMENT, available=lambda block: cast(int, block.extTemp) != 999 and (not getattr(block, 'sensorError', False))), ('sensor', 'humidity'): BlockSensorDescription(key='sensor|humidity', name='Humidity', native_unit_of_measurement=PERCENTAGE, suggested_display_precision=1, device_class=SensorDeviceClass.HUMIDITY, state_class=SensorStateClass.MEASUREMENT, available=lambda block: cast(int, block.humidity) != 999 and (not getattr(block, 'sensorError', False))), ('sensor', 'luminosity'): BlockSensorDescription(key='sensor|luminosity', name='Luminosity', native_unit_of_measurement=LIGHT_LUX, device_class=SensorDeviceClass.ILLUMINANCE, state_class=SensorStateClass.MEASUREMENT, available=lambda block: cast(int, block.luminosity) != -1), ('sensor', 'tilt'): BlockSensorDescription(key='sensor|tilt', name='Tilt', native_unit_of_measurement=DEGREE, translation_key='tilt', state_class=SensorStateClass.MEASUREMENT), ('relay', 'totalWorkTime'): BlockSensorDescription(key='relay|totalWorkTime', name='Lamp life', native_unit_of_measurement=PERCENTAGE, translation_key='lamp_life', value=lambda value: 100 - value / 3600 / SHAIR_MAX_WORK_HOURS, suggested_display_precision=1, extra_state_attributes=lambda block: {'Operational hours': round(cast(int, block.totalWorkTime) / 3600, 1)}, entity_category=EntityCategory.DIAGNOSTIC), ('adc', 'adc'): BlockSensorDescription(key='adc|adc', name='ADC', native_unit_of_measurement=UnitOfElectricPotential.VOLT, suggested_display_precision=2, device_class=SensorDeviceClass.VOLTAGE, state_class=SensorStateClass.MEASUREMENT), ('sensor', 'sensorOp'): BlockSensorDescription(key='sensor|sensorOp', name='Operation', device_class=SensorDeviceClass.ENUM, options=['unknown', 'warmup', 'normal', 'fault'], translation_key='operation', value=lambda value: value, extra_state_attributes=lambda block: {'self_test': block.selfTest}), ('valve', 'valve'): BlockSensorDescription(key='valve|valve', name='Valve status', translation_key='valve_status', device_class=SensorDeviceClass.ENUM, options=['checking', 'closed', 'closing', 'failure', 'opened', 'opening', 'unknown'], entity_category=EntityCategory.DIAGNOSTIC, removal_condition=lambda _, block: block.valve == 'not_connected')}

REST_SENSORS: dict[str, RestSensorDescription] = {'rssi': RestSensorDescription(key='rssi', name='RSSI', native_unit_of_measurement=SIGNAL_STRENGTH_DECIBELS_MILLIWATT, value=lambda status, _: status['wifi_sta']['rssi'], device_class=SensorDeviceClass.SIGNAL_STRENGTH, state_class=SensorStateClass.MEASUREMENT, entity_registry_enabled_default=False, entity_category=EntityCategory.DIAGNOSTIC), 'uptime': RestSensorDescription(key='uptime', name='Uptime', value=lambda status, last: get_device_uptime(status['uptime'], last), device_class=SensorDeviceClass.TIMESTAMP, entity_registry_enabled_default=False, entity_category=EntityCategory.DIAGNOSTIC)}

RPC_SENSORS: dict[str, RpcSensorDescription] = {'power': RpcSensorDescription(key='switch', sub_key='apower', name='Power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'power_em1': RpcSensorDescription(key='em1', sub_key='act_power', name='Power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'power_light': RpcSensorDescription(key='light', sub_key='apower', name='Power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'power_pm1': RpcSensorDescription(key='pm1', sub_key='apower', name='Power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'power_cct': RpcSensorDescription(key='cct', sub_key='apower', name='Power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'power_rgb': RpcSensorDescription(key='rgb', sub_key='apower', name='Power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'power_rgbw': RpcSensorDescription(key='rgbw', sub_key='apower', name='Power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'a_act_power': RpcSensorDescription(key='em', sub_key='a_act_power', name='Phase A active power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'b_act_power': RpcSensorDescription(key='em', sub_key='b_act_power', name='Phase B active power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'c_act_power': RpcSensorDescription(key='em', sub_key='c_act_power', name='Phase C active power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'total_act_power': RpcSensorDescription(key='em', sub_key='total_act_power', name='Total active power', native_unit_of_measurement=UnitOfPower.WATT, device_class=SensorDeviceClass.POWER, state_class=SensorStateClass.MEASUREMENT), 'a_aprt_power': RpcSensorDescription(key='em', sub_key='a_aprt_power', name='Phase A apparent power', native_unit_of_measurement=UnitOfApparentPower.VOLT_AMPERE