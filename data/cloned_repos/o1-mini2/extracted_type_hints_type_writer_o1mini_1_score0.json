{
    "conftest.py_o1_mini_8b971bd2.py": {
        "raiden_spawner": {
            "request": "pytest.FixtureRequest"
        }
    },
    "test_process_custody_slashing.py_o1_mini_01b6d00e.py": {
        "run_standard_custody_slashing_test": {
            "block_lengths": "Optional[list[int]]"
        }
    },
    "test_pipeline.py_o1_mini_2e127b37.py": {
        "test_default_version_range_locks_minor_version": {
            "return": "None"
        }
    },
    "handlers.py_o1_mini_9ad132ce.py": {
        "__init__": {
            "level": "int | str"
        }
    },
    "transformer_layer.py_o1_mini_238a1cf9.py": {
        "forward": {
            "attention_mask": "torch.Tensor"
        }
    },
    "arguments.py_o1_mini_8266a1b7.py": {
        "try_iter_content": {
            "types": "Iterable[Any]"
        },
        "_star_star_dict": {
            "return": "Dict[Any, Any]"
        },
        "iterate_argument_clinic": {
            "return": "Iterator[Union[ValueSet, Iterable[Any]]]"
        }
    },
    "conftest.py_o1_mini_63dfd35f.py": {
        "smartthings_mock_fixture": {
            "return": "Mock"
        }
    },
    "imports.py_o1_mini_95ae2396.py": {
        "iter_module_names": {
            "return": "Iterable[Union[ImportName, SubModuleName]]"
        },
        "__init__": {
            "import_path": "Tuple[Union[str, tree.Name], ...]"
        },
        "_load_python_module": {
            "is_package": "bool"
        }
    },
    "test_indexing.py_o1_mini_3567a5c8.py": {
        "test_get_loc_time_obj2": {
            "monkeypatch": "pytest.MonkeyPatch"
        }
    },
    "events.py_o1_mini_b136f42f.py": {
        "add_realm_logo_fields": {
            "state": "dict[str, Any]"
        }
    },
    "records.py_o1_mini_2fe49890.py": {
        "__getitem__": {
            "key": "typing.Union[str, int]"
        },
        "__init__": {
            "column_maps": "typing.Tuple[typing.Mapping[typing.Any, typing.Tuple[int, TypeEngine]], typing.Mapping[int, typing.Tuple[int, TypeEngine]], typing.Mapping[str, typing.Tuple[int, TypeEngine]]]"
        }
    },
    "melt.py_o1_mini_713be946.py": {
        "melt": {
            "var_name": "Optional[Union[Hashable, List[Hashable]]]"
        },
        "wide_to_long": {
            "stubnames": "Union[str, List[str]]",
            "i": "Union[str, List[str]]"
        },
        "ensure_list_vars": {
            "arg_vars": "Optional[Union[Hashable, Iterable[Hashable]]]"
        },
        "melt_stub": {
            "i": "Union[str, List[str]]"
        }
    },
    "test_rewards.py_o1_mini_775a50b0.py": {
        "test_rewards_nephew_uncle_different_vm": {
            "vm_fn_uncle": "Callable[..., any]",
            "vm_fn_nephew": "Callable[..., any]"
        },
        "test_rewards": {
            "vm_fn": "Callable[[int], any]"
        },
        "test_uncle_block_inclusion_validity": {
            "vm_fn": "Callable[[int], any]"
        },
        "test_rewards_uncle_created_at_different_generations": {
            "vm_fn": "Callable[..., any]"
        }
    },
    "actor.py_o1_mini_fd81ae30.py": {
        "traceback": {
            "return": "str"
        }
    },
    "test_nth.py_o1_mini_48be8cb9.py": {
        "test_groupby_nth_int_like_precision": {
            "data": "Union[Timestamp, int]"
        }
    },
    "conftest.py_o1_mini_7fd8d02c.py": {
        "anova_api_mock": {
            "connect_messages": "list[MockedanovaWebsocketMessage] | None"
        }
    },
    "test_core.py_o1_mini_050b7066.py": {
        "test_method_with_bad_strategy": {
            "x": "Any"
        }
    },
    "test_sliceaware_classifier.py_o1_mini_e30a3084.py": {
        "test_slice_tasks": {
            "return": "None"
        }
    },
    "base.py_o1_mini_49dec30f.py": {
        "on_stream_event_out": {
            "state": "Optional[Dict]"
        }
    },
    "gen.py_o1_mini_1e5c7057.py": {
        "combine_mods": {
            "dict_1": "Dict[str, Union[str, List[str]]]",
            "return": "Dict[str, List[str]]",
            "dict_2": "Dict[str, Union[str, List[str]]]"
        },
        "get_provider": {
            "all_mods": "Dict[str, Dict[str, Union[List[str], str]]]",
            "create_provider_fn": "Callable[[SpecForkName, PresetBaseName, str, List[str]], TestProvider]"
        }
    },
    "period.py_o1_mini_290b79c9.py": {
        "period_range": {
            "start": "Optional[Union[str, datetime, date, Period, ABCSeries]]",
            "end": "Optional[Union[str, datetime, date, Period, ABCSeries]]"
        }
    },
    "test_cat.py_o1_mini_7f01fd9a.py": {
        "test_str_cat_name": {
            "other": "Optional[Callable[[List[str]], Union[Series, Index]]]"
        }
    },
    "exceptions.py_o1_mini_adfa0765.py": {
        "from_httpx_error": {
            "cls": "type[Self]"
        },
        "from_bind_failure": {
            "call_args": "tuple[Any, ...]",
            "call_kwargs": "dict[str, Any]"
        }
    },
    "conftest.py_o1_mini_4058499b.py": {
        "assert_sensor_state": {
            "attributes": "dict[str, Any] | None"
        }
    },
    "test_counts.py_o1_mini_91638839.py": {
        "test_multiple_users_realms_and_times": {
            "return": "None"
        },
        "test_messages_sent_to_stream_by_is_bot_realm_constraint": {
            "return": "None"
        },
        "test_mobile_pushes_received_count": {
            "return": "None"
        },
        "test_multiple_users_realms_and_bots": {
            "return": "None"
        },
        "setUp": {
            "return": "None"
        },
        "test_table_and_id_args": {
            "return": "None"
        },
        "test_process_logging_stat": {
            "return": "None"
        }
    },
    "test_to_csv.py_o1_mini_920b90ae.py": {
        "read_csv": {
            "path": "str"
        },
        "_make_frame": {
            "names": "Optional[List[str]]"
        }
    },
    "range.py_o1_mini_2641469b.py": {
        "__new__": {
            "step": "int | None",
            "stop": "int | None"
        }
    },
    "cache.py_o1_mini_397aeb92.py": {
        "load_module": {
            "return": "Optional[Any]"
        },
        "_set_cache_item": {
            "path": "str"
        }
    },
    "states.py_o1_mini_3a0b7b54.py": {
        "format_exception": {
            "tb": "TracebackType"
        }
    },
    "transactions.py_o1_mini_5c5a8715.py": {
        "chain_id": {
            "return": "Optional[int]"
        }
    },
    "entity.py_o1_mini_067a2f2c.py": {
        "name": {
            "return": "str"
        },
        "__init__": {
            "is_multi_channel": "Optional[bool]"
        }
    },
    "test_thread_runner.py_o1_mini_d2ca7599.py": {
        "test_suggest_resume_scenario": {
            "caplog": "pytest.LogCaptureFixture"
        },
        "test_does_not_log_not_using_async": {
            "caplog": "pytest.LogCaptureFixture"
        },
        "test_stricter_suggest_resume_scenario": {
            "caplog": "pytest.LogCaptureFixture"
        }
    },
    "tools.py_o1_mini_d6227bc0.py": {
        "create_subplots": {
            "ax": "Optional[Union[Axes, Iterable[Axes]]]"
        }
    }
}