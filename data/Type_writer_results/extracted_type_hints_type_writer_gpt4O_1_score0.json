{
    "format.py_gpt4_80a9d557.py": {
        "_get_buffer": {
            "return": "Generator[WriteBuffer[str]] | Generator[StringIO]"
        }
    },
    "span_utils.py_gpt4_841a1d72.py": {
        "iob1_tags_to_spans": {
            "classes_to_ignore": "List[str]"
        },
        "enumerate_spans": {
            "filter_function": "Callable[[List[T]], bool]",
            "max_span_width": "int"
        },
        "bio_tags_to_spans": {
            "classes_to_ignore": "List[str]"
        },
        "bmes_tags_to_spans": {
            "classes_to_ignore": "List[str]"
        },
        "bioul_tags_to_spans": {
            "classes_to_ignore": "List[str]"
        }
    },
    "from_params.py_gpt4_a2a891b9.py": {
        "from_params": {
            "constructor_to_inspect": "Union[Callable[..., T], Callable[[T], None]]",
            "constructor_to_call": "Callable[..., T]",
            "return": "T"
        },
        "infer_constructor_params": {
            "constructor": "Union[Callable[..., T], Callable[[T], None]]"
        }
    },
    "test_tokenize.py_gpt4_f6c0a0ac.py": {
        "get_tokens": {
            "text": "str",
            "return": "list[Token]"
        },
        "assert_tokenizes": {
            "tokens": "list[Token]"
        }
    },
    "bucket_batch_sampler.py_gpt4_ef6e3a39.py": {
        "__init__": {
            "sorting_keys": "List[str]"
        }
    },
    "transformer_layer.py_gpt4_238a1cf9.py": {
        "forward": {
            "attention_mask": "torch.Tensor"
        }
    },
    "generate.py_gpt4_cae18f75.py": {
        "run": {
            "return": "CatalogArtifact"
        }
    },
    "jinja.py_gpt4_8f8d2bb4.py": {
        "get_supported_languages": {
            "node": "jinja2.nodes.Macro"
        }
    },
    "test_freqtradebot.py_gpt4_2b80392e.py": {
        "test_position_adjust2": {
            "return": "None"
        },
        "test_position_adjust": {
            "return": "None"
        }
    },
    "blocks.py_gpt4_268dfb6c.py": {
        "__init__": {
            "timestamp": "int"
        }
    },
    "conftest.py_gpt4_27c9761e.py": {
        "mock_setup_entry": {
            "return": "Generator[AsyncMock]"
        }
    },
    "pytorch_seq2vec_wrapper.py_gpt4_0cdf5468.py": {
        "forward": {
            "hidden_state": "torch.Tensor"
        }
    },
    "evaluator.py_gpt4_8288a291.py": {
        "__call__": {
            "metrics_output_file": "Union[str, PathLike]",
            "batch_weight_key": "str",
            "predictions_output_file": "Union[str, PathLike]"
        }
    },
    "strategy_test_v3.py_gpt4_49c159a8.py": {
        "adjust_trade_position": {
            "min_stake": "float | None",
            "return": "float | None"
        },
        "leverage": {
            "entry_tag": "str | None"
        }
    },
    "adjacency_field.py_gpt4_025db15b.py": {
        "__init__": {
            "labels": "List[str]"
        }
    },
    "common.py_gpt4_c333ba96.py": {
        "clone_table": {
            "where": "str"
        },
        "update_records": {
            "where": "str"
        },
        "get_records": {
            "where": "str",
            "select": "str"
        },
        "delete_records": {
            "where": "str"
        },
        "insert_records": {
            "where": "str"
        }
    },
    "test_exchange.py_gpt4_872a0fde.py": {
        "test__get_stake_amount_limit": {
            "return": "None"
        },
        "test_get_min_pair_stake_amount_real_data": {
            "return": "None"
        }
    },
    "api.py_gpt4_a31f2df4.py": {
        "assign_customer": {
            "wanted": "str"
        },
        "process_action": {
            "timeout": "int"
        }
    },
    "region_detector.py_gpt4_6c3cb449.py": {
        "_seeded_random_tensor": {
            "return": "torch.FloatTensor"
        }
    },
    "conftest.py_gpt4_ef4e97b9.py": {
        "mock_controller": {
            "return": "Generator[AsyncMock]"
        }
    },
    "beam_search_test.py_gpt4_e8e5dc23.py": {
        "_check_results": {
            "state": "Dict[str, torch.Tensor]"
        }
    },
    "ewm.py_gpt4_64027fd2.py": {
        "__init__": {
            "return": "None"
        }
    },
    "token_characters_indexer.py_gpt4_ea93cfc1.py": {
        "__init__": {
            "end_tokens": "List[str]",
            "start_tokens": "List[str]"
        }
    },
    "test_callables.py_gpt4_03d6aa1c.py": {
        "test_function_with_complex_args_across_v1_and_v2": {
            "tmp_path": "Path"
        },
        "f": {
            "x": "datetime.datetime"
        }
    },
    "combined.py_gpt4_3818a3a8.py": {
        "step": {
            "metric": "float"
        },
        "step_batch": {
            "batch_num_total": "int"
        }
    },
    "find_learning_rate.py_gpt4_5b4e5b17.py": {
        "find_learning_rate_model": {
            "stopping_factor": "float"
        },
        "search_learning_rate": {
            "stopping_factor": "float"
        }
    },
    "commands.py_gpt4_df9e3a12.py": {
        "_create_app": {
            "environment": "str",
            "config_override": "Dict[str, Any]"
        }
    },
    "py2md.py_gpt4_0d5aee8c.py": {
        "_format_function_signature": {
            "override_name": "str"
        }
    },
    "bimpm_matching.py_gpt4_70e09fb8.py": {
        "__init__": {
            "is_forward": "bool"
        }
    },
    "conll2003.py_gpt4_c0cefa4c.py": {
        "text_to_instance": {
            "pos_tags": "List[str]",
            "chunk_tags": "List[str]",
            "ner_tags": "List[str]"
        },
        "__init__": {
            "token_indexers": "Dict[str, TokenIndexer]"
        }
    },
    "elmo_indexer.py_gpt4_56f6acdb.py": {
        "__init__": {
            "tokens_to_add": "Dict[str, int]"
        },
        "as_padded_tensor_dict": {
            "return": "Dict[str, torch.Tensor]"
        }
    },
    "raiden_service.py_gpt4_abb03416.py": {
        "mediated_transfer_async": {
            "route_states": "List[RouteState]"
        },
        "initiator_init": {
            "route_states": "List[RouteState]"
        }
    },
    "transactions.py_gpt4_e917af4b.py": {
        "as_signed_transaction": {
            "chain_id": "int"
        }
    },
    "learning_rate_scheduler.py_gpt4_290a2bf8.py": {
        "step": {
            "metric": "float"
        }
    },
    "pretrained_transformer_mismatched_indexer.py_gpt4_718c7bc6.py": {
        "__init__": {
            "max_length": "int"
        }
    },
    "funcdef_return_type_trailing_comma.py_gpt4_9d900532.py": {
        "SimplePyFn": {
            "buffer_input": "Buffer[UInt8, 2]",
            "return": "tuple[Buffer[UInt8, 2], Buffer[UInt8, 2]]",
            "float_arg": "Scalar[Float32]",
            "context": "hl.GeneratorContext",
            "func_input": "Buffer[Int32, 2]"
        },
        "aaaaaaaaaaaaaaaaa": {
            "return": "list[Ccccccccccccccccccccccccccccccccccccccccccccccccccc, Dddddd]"
        },
        "thiiiiiiiiiiiiiiiiiis_iiiiiiiiiiiiiiiiiiiiiiiiiiiiiis_veeeeeeeeeeeeeeeeeeeeeeery_looooooong": {
            "return": "None"
        },
        "a": {
            "return": "tuple[a, b]"
        },
        "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa": {
            "return": "cccccccccccccccccccccccccccccc"
        },
        "foo": {
            "return": "list[a, b]"
        }
    },
    "pytorch_seq2seq_wrapper.py_gpt4_2eda3bde.py": {
        "forward": {
            "hidden_state": "torch.Tensor"
        }
    },
    "classification.py_gpt4_554b95c0.py": {
        "catboost_classification_learner": {
            "weight_column": "str"
        },
        "logistic_classification_learner": {
            "weight_column": "str"
        },
        "xgb_classification_learner": {
            "weight_column": "str"
        }
    },
    "model.py_gpt4_1a9c1b3c.py": {
        "extend_embedder_vocab": {
            "embedding_sources_mapping": "Dict[str, str]"
        }
    },
    "transactions.py_gpt4_125a38fe.py": {
        "as_signed_transaction": {
            "chain_id": "int"
        }
    },
    "document.py_gpt4_99eb2cc1.py": {},
    "mypy.py_gpt4_6c8d5216.py": {
        "error_extra_fields_on_root_model": {
            "api": "CheckerPluginInterface"
        }
    },
    "testclient.py_gpt4_b53c0624.py": {
        "__enter__": {
            "return": "TestClient"
        }
    },
    "text_classification_json.py_gpt4_45388262.py": {
        "__init__": {
            "max_sequence_length": "int",
            "token_indexers": "Dict[str, TokenIndexer]"
        },
        "text_to_instance": {
            "label": "Union[str, int]"
        }
    },
    "utils.py_gpt4_4ba154ec.py": {
        "create_report_notification": {
            "extra": "Optional[dict[str, Any]]",
            "owners": "Optional[list[User]]"
        },
        "insert_report_schedule": {
            "recipients": "Optional[list[ReportRecipients]]",
            "logs": "Optional[list[ReportExecutionLog]]",
            "owners": "list[User]",
            "extra": "Optional[dict[Any, Any]]"
        }
    },
    "heartbeat.py_gpt4_3d4f9698.py": {
        "find_by_id": {
            "customers": "List[str]"
        },
        "__init__": {
            "origin": "str",
            "create_time": "datetime",
            "customer": "str",
            "tags": "List[str]",
            "timeout": "int"
        },
        "find_all_by_status": {
            "status": "List[str]"
        }
    },
    "predict.py_gpt4_ba4516a8.py": {
        "_maybe_print_to_console_and_file": {
            "model_input": "str"
        }
    },
    "python.py_gpt4_6ca98bab.py": {
        "get_raiden_internal_events_with_timestamps": {
            "offset": "int",
            "limit": "int"
        },
        "get_raiden_events_payment_history_with_timestamps": {
            "offset": "int",
            "limit": "int"
        },
        "transfer_and_wait": {
            "transfer_timeout": "int"
        }
    },
    "span_based_f1_measure.py_gpt4_e66cb97e.py": {
        "__call__": {
            "mask": "Optional[torch.BoolTensor]"
        },
        "__init__": {
            "ignore_classes": "List[str]"
        }
    },
    "client_proto.py_gpt4_b5fecce6.py": {
        "close": {
            "return": "None"
        }
    }
}